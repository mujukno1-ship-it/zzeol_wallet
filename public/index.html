<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>사토시의지갑 v10.1 — 사람형 접속즉시 표시 + 새후보 상단 고정</title>
<style>
  :root{--bg:#0b0f14;--panel:#111823;--muted:#8fa4c7;--text:#e8eefc;--up:#22c55e;--down:#ef4444}
  *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 "Noto Sans KR",system-ui}
  .wrap{max-width:1100px;margin:20px auto;padding:16px}
  .card{background:var(--panel);border:1px solid #1b2738;border-radius:16px;padding:14px;box-shadow:0 6px 20px rgba(0,0,0,.25);margin-bottom:14px}
  h2{margin:0 0 8px} .status{font-size:12px;color:#9bb0d1}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  input,button{border:1px solid #2a3b57;background:#0f1b2e;color:#dbe7ff;border-radius:10px;padding:10px 12px}
  button{cursor:pointer} button[disabled]{opacity:.55}
  table{width:100%;border-collapse:separate;border-spacing:0 8px;margin-top:10px}
  thead th{font-size:12px;color:#8fa4c7;text-align:left;padding:0 10px}
  tbody tr{background:#0e1520;border:1px solid #1d2a40} tbody td{padding:10px;vertical-align:middle}
  .price{font-variant-numeric:tabular-nums} .up{color:var(--up)} .down{color:var(--down)}
  .tag{font-size:11px;padding:3px 6px;border:1px solid #2a3956;border-radius:6px;background:#111a27;color:#9fb6db}
  .act{padding:4px 8px;border-radius:999px;border:1px solid #2a3956}
  .act.buy{color:#9ff4b1;border-color:#2b5b3a}.act.sell{color:#ffb4b4;border-color:#6b2b2b}.act.hold{color:#c9d4eb}
  .pin{cursor:pointer;font-size:16px;line-height:1} .pinned{color:#ffd54a}
</style>
</head>
<body>
<div class="wrap">

  <!-- ★ 고정 코인 -->
  <div class="card">
    <h2>★ 고정 코인 — 접속 시 항상 유지</h2>
    <div class="status">행의 ★/☆ 클릭으로 고정/해제(브라우저에 저장)</div>
    <table>
      <thead>
        <tr>
          <th style="width:6%">★</th>
          <th style="width:14%">코인</th>
          <th style="width:12%">현재가</th>
          <th style="width:10%">등락</th>
          <th style="width:12%">매수</th>
          <th style="width:12%">매도</th>
          <th style="width:12%">손절</th>
          <th style="width:10%">위험도</th>
          <th>쩔어 한마디</th>
        </tr>
      </thead>
      <tbody id="pinnedBody">
        <tr><td colspan="9" class="status">고정된 코인이 없습니다. 아래 표에서 ★을 눌러 고정하세요.</td></tr>
      </tbody>
    </table>
  </div>

  <!-- 🔥 예열 자동예측 -->
  <div class="card">
    <h2>🔥 예열 자동예측 — 항상 표시(캐시 복원 + 실시간)</h2>
    <div class="status">새 후보가 감지되면 자동으로 <b>상단</b>에 배치됩니다.</div>
    <table>
      <thead>
        <tr>
          <th style="width:6%">★</th>
          <th style="width:14%">코인</th>
          <th style="width:12%">현재가</th>
          <th style="width:10%">등락</th>
          <th style="width:12%">매수</th>
          <th style="width:12%">매도</th>
          <th style="width:12%">손절</th>
          <th style="width:10%">위험도</th>
          <th>쩔어 한마디</th>
        </tr>
      </thead>
      <tbody id="preheatBody">
        <tr><td colspan="9" class="status">최근 예열 캐시 없음 — 실시간 스캔 대기…</td></tr>
      </tbody>
    </table>
  </div>

  <!-- 🧭 사람형 AI 타점 (요청 컬럼 전부) -->
  <div class="card">
    <h2>🧭 사람형 AI 표 — 접속 즉시 채워짐 + 새후보 상단 반영</h2>
    <div class="status">우선순위: <b>고정 코인 ▶ 예열 캐시/신규(상단) ▶ 기본 시드</b></div>
    <table>
      <thead>
        <tr>
          <th style="width:6%">★</th>
          <th style="width:14%">코인</th>
          <th style="width:12%">현재가</th>
          <th style="width:10%">등락</th>
          <th style="width:12%">매수</th>
          <th style="width:12%">매도</th>
          <th style="width:12%">손절</th>
          <th style="width:10%">위험도</th>
          <th>쩔어 한마디</th>
        </tr>
      </thead>
      <tbody id="aiBody">
        <tr><td colspan="9" class="status">분석 대기…</td></tr>
      </tbody>
    </table>
  </div>

  <!-- 🔎 검색 -->
  <div class="card">
    <h2>🔎 코인 검색 (KRW 전용)</h2>
    <div class="row">
      <input id="q" placeholder="예: 이더리움/ETH, 이더리움클래식/ETC, 에이다/ADA, 시바/SHIB">
      <button id="btnSearch">검색</button>
      <button id="btnReset">초기화</button>
    </div>
    <div class="status" id="status">마켓 목록 로드 중…</div>
    <table>
      <thead><tr>
        <th style="width:6%">★</th>
        <th style="width:22%">코인</th><th style="width:14%">현재가</th><th style="width:12%">등락</th>
        <th style="width:14%">매수</th><th style="width:14%">매도</th><th style="width:14%">손절</th><th>비고</th>
      </tr></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <!-- ⚙️ 상태 -->
  <div class="card">
    <h2>⚙️ 시스템 상태</h2>
    <div class="status" id="net">초기화 중…</div>
  </div>

</div>

<script>
/* ===== 기본 설정 ===== */
const API={
  REST_MARKETS:'https://api.upbit.com/v1/market/all?isDetails=true',
  REST_TICKER:(codes)=>`https://api.upbit.com/v1/ticker?markets=${codes.join(',')}`,
  CANDLE:(m,f)=> f==='1d'
    ? `https://api.upbit.com/v1/candles/days?market=${m}&count=200`
    : `https://api.upbit.com/v1/candles/minutes/${f==='4h'?240:60}?market=${m}&count=200`,
  LOCAL:(url)=>`/api/upbit?url=${encodeURIComponent(url)}`
};
const TH={preNearHighPct:0.005, preMinMove:0.002, preMaxMove:0.020, preAccel:1.6, baselineMin:600};
const LS_PREHEAT='ZWL_PREHEAT_V6';       // 예열 캐시
const LS_PINNED='ZWL_PINNED_V1';         // 고정 코인
const DEFAULT_SEED=['KRW-BTC','KRW-ETH','KRW-ADA','KRW-XRP','KRW-SOL','KRW-SHIB']; // 접속 즉시 사람형 표에 채워질 시드

/* ===== 상태/유틸 ===== */
const el={pinnedBody:byId('pinnedBody'),preheatBody:byId('preheatBody'),aiBody:byId('aiBody'),tbody:byId('tbody'),status:byId('status'),net:byId('net'),q:byId('q')};
const st={markets:[],dict:{},tickers:new Map(),hist:new Map(),rx:0,last:0,pinned:new Set()};
function byId(id){return document.getElementById(id)}
function debounce(fn,ms){let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),ms)}}
function tick(p){if(p>=2e6)return 1e3;if(p>=1e6)return 500;if(p>=5e5)return 100;if(p>=1e5)return 50;if(p>=1e4)return 10;if(p>=1e3)return 5;if(p>=100)return 1;if(p>=10)return .1;if(p>=1)return .01;return .001;}
function fKRW(p){if(typeof p!=='number'||!isFinite(p)) return '-'; const t=tick(p);const d=t>=1?0:t===.1?1:t===.01?2:3;return Number(p||0).toLocaleString('ko-KR',{minimumFractionDigits:d,maximumFractionDigits:d})}
function pct(v){return (Number(v||0)*100).toFixed(2)+'%'}
async function fetchUpbit(url){try{const r=await fetch(url,{cache:'no-store'});if(r.ok)return await r.json()}catch{} const r=await fetch(API.LOCAL(url));return await r.json()}
function levels(p){ const k=tick(p); return {buy:p-2*k, sell:p+3*k, cut:p-6*k}; }

/* ===== 로컬 저장 ===== */
function loadPinned(){ try{ st.pinned=new Set(JSON.parse(localStorage.getItem(LS_PINNED)||'[]')); }catch{ st.pinned=new Set(); } }
function savePinned(){ localStorage.setItem(LS_PINNED, JSON.stringify([...st.pinned])); }
function loadPreheat(){ try{ const a=JSON.parse(localStorage.getItem(LS_PREHEAT)||'[]'); return Array.isArray(a)?a:[]; }catch{return []} }
function savePreheat(arr){ localStorage.setItem(LS_PREHEAT, JSON.stringify(arr)); }

/* ===== 검색(간단 매핑 포함) ===== */
function norm(s){return (s||'').toString().toLowerCase().replace(/\s+/g,'')}
function buildSearchIndex(){
  st.dict={};
  const add=(k,m)=>{ if(!k) return; const key=norm(k); (st.dict[key]??=[]).push(m); };
  for(const m of st.markets){
    add(m.market,m); add(m.korean_name,m); add(m.english_name,m); add((m.korean_name||'').replace(/\s+/g,''),m);
    if(m.market==='KRW-ETH'){ ['이더리움','eth','이더'].forEach(a=>add(a,m)); }
    if(m.market==='KRW-ETC'){ ['이더리움클래식','이더리움 클래식','클래식','etc'].forEach(a=>add(a,m)); }
    if(m.market==='KRW-ADA'){ ['에이다','ada','카르다노','cardano'].forEach(a=>add(a,m)); }
    if(m.market==='KRW-SHIB'){ ['시바이누','시바','shib','shiba'].forEach(a=>add(a,m)); }
    if(m.market==='KRW-DOGE'){ ['도지','도지코인','doge','dogecoin'].forEach(a=>add(a,m)); }
    if(m.market==='KRW-XRP'){ ['리플','xrp'].forEach(a=>add(a,m)); }
    if(m.market==='KRW-SOL'){ ['솔라나','sol','solana'].forEach(a=>add(a,m)); }
  }
}
function searchAll(q){
  if(!q) return st.markets.slice(0,20);
  const key=norm(q);
  let list=(st.dict[key]??[]).slice(0);
  if(list.length<30){
    const extra=st.markets.filter(m=>{
      const n1=norm(m.korean_name), n2=(m.english_name||'').toLowerCase(), n3=m.market.toLowerCase();
      return n1.includes(key)||n2.includes(key)||n3.includes(key);
    });
    extra.forEach(m=>{ if(!list.find(x=>x.market===m.market)) list.push(m); });
  }
  if(/이더리움/.test(key)){ ['KRW-ETH','KRW-ETC'].forEach(code=>{ const m=st.markets.find(x=>x.market===code); if(m && !list.find(x=>x.market===m.market)) list.unshift(m); }); }
  return list.slice(0,30);
}

/* ===== 폴링/통계/예열 ===== */
async function pollTickers(){
  const codes=st.markets.map(m=>m.market); const chunk=80; const now=Date.now();
  for(let i=0;i<codes.length;i+=chunk){
    try{
      const arr=await fetchUpbit(API.REST_TICKER(codes.slice(i,i+chunk)));
      for(const t of arr){
        const price=Number(t.trade_price), chg=Number(t.signed_change_rate);
        st.tickers.set(t.market,{market:t.market,trade_price:price, high_price:Number(t.high_price), signed_change_rate:isFinite(chg)?chg:0, acc_trade_price_24h:Number(t.acc_trade_price_24h||0), ts:now});
        const h=st.hist.get(t.market)||[]; h.push({ts:now,price:price,acc:Number(t.acc_trade_price_24h||0),high:Number(t.high_price||price)});
        const cut=now-TH.baselineMin*1000; while(h.length&&h[0].ts<cut)h.shift(); st.hist.set(t.market,h);
      }
    }catch{}
  }
  st.rx++; st.last=now; el.net.textContent=`연결 OK · 수신 ${st.rx} · 마지막 ${new Date(st.last).toLocaleTimeString()}`;
}
function oneMin(m){ const arr=st.hist.get(m)||[]; if(arr.length<2) return null; const now=Date.now(), pastTs=now-60*1000;
  let past=arr[0]; for(let i=arr.length-1;i>=0;i--){ if(arr[i].ts<=pastTs){ past=arr[i]; break; } }
  const cur=arr[arr.length-1], old=arr.find(x=>x.ts>=now-600*1000)||arr[0];
  const base=(Math.max(0,cur.acc-old.acc))/Math.max(1,(cur.ts-old.ts)/60000);
  const pct=(past.price>0?(cur.price-past.price)/past.price:0);
  const accel=base>0?(Math.max(0,cur.acc-past.acc)/base):0;
  const near=(cur.high>0)?Math.max(0,(cur.high-cur.price)/cur.high):1;
  return {pct,accel,near,price:cur.price,high:cur.high};
}
function riskScore(s){ const near=(1-Math.min(1,s.near))*0.5, accel=Math.min(3,s.accel)/3*0.35, gain=Math.max(0,Math.min(1,(s.pct-0.002)/(0.02-0.002)))*0.15; return Math.max(0.8, Math.min(2.2, 1.0+near+accel+gain-0.1)); }
function oneLinerFromStat(s){ const r=riskScore(s); if(s.pct>0.015&&s.accel>2.2&&s.near<0.003)return{act:'buy',msg:'점화 직전 — 1차 진입 관점',risk:r}; if(s.pct>0.008&&s.accel>1.8)return{act:'hold',msg:'가열 진행 — 눌림 확인 후 추격 금지',risk:r}; if(s.pct<0.003)return{act:'hold',msg:'예열 초기 — 관망/감시',risk:r}; return{act:'hold',msg:'조건 모니터링 지속',risk:r}; }

/* ===== 예열 스캔 (신규: 상단 배치) ===== */
function mergeAndSortPreheat(newList){
  // 기존 캐시 + 신규 병합, ts 큰(=최신) 순서로 정렬 → 상단 배치
  const mp=new Map(loadPreheat().map(x=>[x.market,x]));
  newList.forEach(n=>mp.set(n.market,n));
  const merged=[...mp.values()].sort((a,b)=>b.ts-a.ts).slice(0,48);
  savePreheat(merged);
  return merged;
}
const scanPreheat = debounce(function(){
  const found=[];
  for(const m of st.markets){
    const s=oneMin(m.market); if(!s) continue;
    if(s.near<=TH.preNearHighPct && s.pct>=TH.preMinMove && s.pct<=TH.preMaxMove && s.accel>=TH.preAccel){
      found.push({market:m.market, name:m.korean_name||m.english_name||m.market, ts:Date.now(), ...s});
    }
  }
  const list = found.length ? mergeAndSortPreheat(found) : loadPreheat();
  renderPreheat(list); renderPinned(); renderAI(); // 새 후보가 있으면 자동 상단 반영
}, 250);

/* ===== 공통 행 & 핀 ===== */
function rowHTML(market, name, price, chg, lv, stat){
  const cls=(chg||0)>=0?'up':'down'; const one=stat?oneLinerFromStat(stat):{act:'hold',msg:'관망',risk:1.3};
  const pinned=st.pinned.has(market);
  return `
    <td><span class="pin ${pinned?'pinned':''}" data-m="${market}" title="${pinned?'고정 해제':'고정'}">${pinned?'★':'☆'}</span></td>
    <td><span class="tag">${market.replace('KRW-','')}</span> ${name||''}</td>
    <td class="price ${cls}">${fKRW(price)}</td>
    <td class="${cls}">${pct(chg)}</td>
    <td class="price">${fKRW(lv.buy)}</td>
    <td class="price">${fKRW(lv.sell)}</td>
    <td class="price">${fKRW(lv.cut)}</td>
    <td>${(one.risk||1.3).toFixed(2)}</td>
    <td><span class="act ${one.act}">${one.act==='buy'?'매수':one.act==='sell'?'매도':'관망'}</span> · ${one.msg}</td>`;
}
function wirePins(tbody){
  tbody.querySelectorAll('.pin').forEach(el=>{
    el.onclick=()=>{
      const code=el.getAttribute('data-m');
      if(st.pinned.has(code)) st.pinned.delete(code); else st.pinned.add(code);
      savePinned(); renderPinned(); renderAI(); // 고정 즉시 반영
    };
  });
}

/* ===== 렌더: 고정/예열/검색 ===== */
function renderPinned(){
  const body=el.pinnedBody; const codes=[...st.pinned];
  if(!codes.length){ body.innerHTML='<tr><td colspan="9" class="status">고정된 코인이 없습니다. 아래 표에서 ★을 눌러 고정해 보세요.</td></tr>'; return; }
  body.innerHTML='';
  for(const code of codes){
    const m=st.markets.find(x=>x.market===code)||{korean_name:code}; const t=st.tickers.get(code); if(!t||typeof t.trade_price!=='number') continue;
    const lv=levels(t.trade_price); const stat=oneMin(code)||{pct:0,accel:0,near:1};
    const tr=document.createElement('tr'); tr.innerHTML=rowHTML(code, m.korean_name, t.trade_price, t.signed_change_rate, lv, stat);
    body.appendChild(tr);
  }
  wirePins(body);
}
function renderPreheat(arr){
  const body=el.preheatBody;
  if(!arr||!arr.length){ body.innerHTML='<tr><td colspan="9" class="status">예열 후보 없음(감시 중)</td></tr>'; return; }
  body.innerHTML='';
  for(const it of arr){
    const t=st.tickers.get(it.market); if(!t||typeof t.trade_price!=='number') continue;
    const lv=levels(t.trade_price);
    const tr=document.createElement('tr'); tr.innerHTML=rowHTML(it.market, it.name, t.trade_price, t.signed_change_rate, lv, it);
    body.appendChild(tr);
  }
  wirePins(body);
}
function renderTable(list){
  const tb=el.tbody; tb.innerHTML='';
  if(!list.length){ tb.innerHTML='<tr><td colspan="8" class="status">검색 결과 없음</td></tr>'; return; }
  for(const m of list){
    const t=st.tickers.get(m.market); if(!t||typeof t.trade_price!=='number') continue;
    const lv=levels(t.trade_price); const stat=oneMin(m.market)||{pct:0,accel:0,near:1};
    const tr=document.createElement('tr'); tr.innerHTML=rowHTML(m.market, m.korean_name||m.english_name||'', t.trade_price, t.signed_change_rate, lv, stat);
    tb.appendChild(tr);
  }
  wirePins(tb);
}

/* ===== 사람형 AI: 접속 즉시 채우기 + 새후보 상단 반영 ===== */
function initialTargets(){
  // 1) 고정 코인
  const pinned=[...st.pinned];
  if(pinned.length) return pinned;

  // 2) 예열 캐시(최신 상단)
  const cached = loadPreheat().sort((a,b)=>b.ts-a.ts).map(x=>x.market);
  if(cached.length) return cached.slice(0,8);

  // 3) 기본 시드(항상 보장) — 접속 즉시 사람형 표에 코인 나타나도록
  return DEFAULT_SEED;
}
async function analyzeHuman(market){
  const [h1]=await Promise.all([fetchUpbit(API.CANDLE(market,'1h'))]); // 경량화
  if(!h1.length) throw new Error('no candles');
  const price = h1[h1.length-1].trade_price;
  const t = st.tickers.get(market)||{trade_price:price, signed_change_rate:0};
  const lv = levels(t.trade_price||price);
  return {market, name:(st.markets.find(x=>x.market===market)?.korean_name)||market, price:t.trade_price||price, chg:t.signed_change_rate||0, lv};
}
async function renderAI(useList){
  const body=el.aiBody;
  const targets = (Array.isArray(useList)&&useList.length?useList:initialTargets()).slice(0,12);
  if(!targets.length){ body.innerHTML='<tr><td colspan="9" class="status">대상 없음</td></tr>'; return; }
  body.innerHTML='<tr><td colspan="9" class="status">분석 중…</td></tr>';
  const res = await Promise.allSettled(targets.map(analyzeHuman));
  const rows = res.filter(x=>x.status==='fulfilled').map(x=>x.value);
  if(!rows.length){ body.innerHTML='<tr><td colspan="9" class="status">분석 실패 — 잠시 후 자동 재시도</td></tr>'; return; }
  body.innerHTML='';
  for(const r of rows){
    const t=st.tickers.get(r.market)||{trade_price:r.price,signed_change_rate:r.chg};
    const stat=oneMin(r.market)||{pct:0,accel:0,near:1};
    const tr=document.createElement('tr'); tr.innerHTML=rowHTML(r.market, r.name, t.trade_price, t.signed_change_rate, r.lv, stat);
    body.appendChild(tr);
  }
  wirePins(body);
}

/* ===== 이벤트 ===== */
function onSearch(){
  const key=el.q.value.trim();
  const list=searchAll(key);
  renderTable(list);
  renderAI(list.slice(0,12).map(m=>m.market)); // 검색 시 사람형 표도 교체
}
byId('btnSearch').onclick=onSearch;
el.q.onkeydown=(e)=>{ if(e.key==='Enter') onSearch(); };
byId('btnReset').onclick=()=>{ el.q.value=''; renderTable(st.markets.slice(0,20)); renderAI(); };

/* ===== 시작 ===== */
(async function start(){
  loadPinned();
  try{
    const data=await fetchUpbit(API.REST_MARKETS);
    st.markets=data.filter(x=>x.market?.startsWith('KRW-'));
    el.status.textContent=`KRW ${st.markets.length}종 로드 완료`;
  }catch{
    // 업비트 막히면 시드만으로도 사람형 표가 보이게 처리
    st.markets=DEFAULT_SEED.map(code=>({market:code,korean_name:code.replace('KRW-','')}));
    el.status.textContent='업비트 연결 실패 — 기본 시드로 가동';
  }
  buildSearchIndex();

  // 접속 즉시: 예열(캐시) 렌더 + 사람형 표에 반드시 대상 채워넣기
  renderPreheat(loadPreheat().sort((a,b)=>b.ts-a.ts));
  renderPinned();
  await pollTickers();
  renderTable(st.markets.slice(0,20));
  renderAI(); // ← 접속 즉시 사람형 표가 비지 않도록 시드/캐시/고정 순으로 채움
  scanPreheat(); // 이후 신규 예열이 생기면 mergeAndSortPreheat로 상단 반영
  setInterval(async()=>{ await pollTickers(); scanPreheat(); }, 1000);
})();
</script>
</body>
</html>
