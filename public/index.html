<script>
/* =========================
   업비트 KRW 호가단위/표시
   ========================= */
const $=(id)=>document.getElementById(id);
const pct=v=>`${v>0?'+':''}${(Number(v)||0).toFixed(2)}%`;

function tickSizeKRW(p){
  p=Number(p)||0;
  if(p>=2000000) return 1000;
  if(p>=1000000) return 500;
  if(p>=500000)  return 100;
  if(p>=100000)  return 50;
  if(p>=10000)   return 10;
  if(p>=1000)    return 5;
  if(p>=100)     return 1;
  if(p>=10)      return 0.1;
  if(p>=1)       return 0.01;
  if(p>=0.1)     return 0.001;
  return 0.0001;
}
const dec=(t)=>String(t).includes('.')?String(t).split('.')[1].length:0;
const roundTick=(v,t,dir='nearest')=>{
  const n=v/t; let r=n;
  if(dir==='down') r=Math.floor(n);
  else if(dir==='up') r=Math.ceil(n);
  else r=Math.round(n);
  return Number((r*t).toFixed(dec(t)));
};
const fmtKRW=(v)=>{const t=tickSizeKRW(v);return Number(v||0).toLocaleString('ko-KR',{minimumFractionDigits:dec(t),maximumFractionDigits:dec(t)})};

/* =========================
   설정(쉽게 바꿀 수 있음)
   ========================= */
const CONF = {
  BASE_TICKS: 2,              // 스프레드 보정: 기본 N틱
  MAX_TICKS: 6,               // 최대 확장
  FEE: 0.0005,                // 왕복 0.05% 가정(원하면 0.0007 등으로)
  ATR_LEN: 14,                // ATR 기간(분)
  ATR_K: 0.8,                 // ATR 배수 (0.6~1.2 권장)
  KIMCHI_1: 2,                // |김치| >= 2% → +1틱
  KIMCHI_2: 4,                // |김치| >= 4% → +2틱
  ONCHAIN_WEAK: -1.5          // 온체인 총량 24h <= -1.5% → +1틱
};

/* =========================
   마켓 매핑(편한 검색)
   ========================= */
let MARKET_MAP=null;
(async()=>{try{MARKET_MAP=(await (await fetch('/api/markets')).json()).map;}catch{}})();
function toMarket(t){
  const raw=(t||'').trim(); if(!raw) return 'KRW-ETH';
  const key=raw.toUpperCase().replace(/\s+/g,'').replace(/-/g,'');
  if(MARKET_MAP && MARKET_MAP[key]) return MARKET_MAP[key];
  if(key==='비트코인'||key==='BTC') return 'KRW-BTC';
  if(key==='이더리움'||key==='ETH') return 'KRW-ETH';
  if(key==='비트코인캐시'||key==='BCH') return 'KRW-BCH';
  if(/^KRW-[A-Z]+$/.test(raw.toUpperCase())) return raw.toUpperCase();
  return 'KRW-'+raw.toUpperCase();
}

/* =========================
   위험도(간단)
   ========================= */
function riskScore(changePct, kimchiPct){
  if(kimchiPct==null) return {label:'관망', cls:'warn'};
  if(Math.abs(changePct)<0.8 && Math.abs(kimchiPct)<1.0) return {label:'관망', cls:'warn'};
  if(changePct>=1.2 && kimchiPct>=1.5) return {label:'주의', cls:'warn'};
  if(changePct<=-1.2 || kimchiPct>=4.0) return {label:'경고', cls:'dang'};
  return {label:'보통', cls:'ok'};
}

/* =========================
   데이터 로드
   ========================= */
async function loadSummary(market){
  const r=await fetch(`/api/summary?market=${encodeURIComponent(market)}`);
  if(!r.ok) throw new Error('summary http '+r.status);
  return r.json();
}
async function loadATR(market, len=CONF.ATR_LEN){
  try{
    const r=await fetch(`/api/atr?market=${encodeURIComponent(market)}&len=${len}`);
    if(!r.ok) return null;
    return await r.json(); // { ok:true, atr }
  }catch{return null;}
}

/* =========================
   요약 렌더 + 타점 계산
   ========================= */
async function renderSummaryWithTargets(s){
  const up=s?.upbit;
  if(!up){
    $('systemBadge').innerHTML="시스템: <b style='color:#ef4444'>오류</b>";
    return;
  }
  const chg=(up.signed_change_price/up.prev_closing_price)*100;
  const tick=tickSizeKRW(up.trade_price);

  // 기본 정보
  $('symPill').textContent=up.market.replace('KRW-','');
  $('price').textContent=fmtKRW(up.trade_price);
  $('chg').textContent=pct(chg); $('chg').className=chg>=0?'green':'red';

  // 보조지표
  const kp = s?.kimchi?.kimchi ?? null;
  if(kp!=null){$('kimchi').textContent=pct(kp); $('kimchi').className=kp>=0?'green':'red';}
  else{$('kimchi').textContent='-';$('kimchi').className='muted';}

  if(s?.onchain?.ok){
    const t=s.onchain.total;
    $('onchain').textContent=`₩${Number(t.mcapKRW).toLocaleString('ko-KR')} (${pct(t.change24h)}) ${t.risk||''}`;
    $('onchain').className=t.change24h<0?'red':(t.change24h>0?'green':'muted');
  }else{$('onchain').textContent='오류';$('onchain').className='red'}

  // 위험도 뱃지
  const rk=riskScore(chg,kp);
  $('riskChip').textContent='위험도: '+rk.label;
  $('riskChip').className='risk '+rk.cls;

  // ===== 타점 계산 =====
  // ① 스프레드 기반
  let N = CONF.BASE_TICKS;
  if(kp!=null){
    if(Math.abs(kp) >= CONF.KIMCHI_2) N += 2;
    else if(Math.abs(kp) >= CONF.KIMCHI_1) N += 1;
  }
  const oc = s?.onchain?.total?.change24h ?? 0;
  if(oc < CONF.ONCHAIN_WEAK) N += 1;
  N = Math.min(CONF.MAX_TICKS, Math.max(1, N));

  // ② ATR 기반 가변 밴드 (있으면 적용)
  let rawBuy = up.bid_price - N*tick;
  let rawSell= up.ask_price + N*tick;

  try{
    const atrData = await loadATR(up.market, CONF.ATR_LEN);
    if(atrData?.ok && atrData.atr>0){
      const mid = (up.bid_price + up.ask_price)/2;
      const band = CONF.ATR_K * atrData.atr;
      rawBuy = Math.min(rawBuy, mid - band);
      rawSell= Math.max(rawSell, mid + band);
    }
  }catch{}

  // ③ 수수료 보정(왕복 fee 고려)
  rawBuy  = rawBuy  * (1 - CONF.FEE);
  rawSell = rawSell * (1 + CONF.FEE);

  // ④ 틱 반올림 + 표시
  const buyTarget  = roundTick(rawBuy , tick, 'down');
  const sellTarget = roundTick(rawSell, tick, 'up');
  $('buy').textContent = fmtKRW(buyTarget);
  $('sell').textContent = fmtKRW(sellTarget);

  // 시스템 상태/업데이트
  const ok=!!up && (s?.kimchi?.kimchi!=null);
  $('systemBadge').innerHTML=ok?"시스템: <b style='color:#22c55e'>OK</b>":"시스템: <b style='color:#ef4444'>오류</b>";
  $('updatedAt').innerHTML=`<small>${new Date().toLocaleTimeString()}</small>`;
}

/* =========================
   주기 갱신
   ========================= */
let currentMarket='KRW-ETH', timer=null;
async function tick(){
  try{$('loader').style.display='inline-flex'; const s=await loadSummary(currentMarket); await renderSummaryWithTargets(s);}
  catch(e){console.error(e);$('systemBadge').innerHTML="시스템: <b style='color:#ef4444'>오류</b>";}
  finally{$('loader').style.display='none';}
}
document.getElementById('searchBtn').addEventListener('click', ()=>{
  currentMarket=toMarket(document.getElementById('q').value);
  clearInterval(timer); tick(); timer=setInterval(tick,1500);
});
tick(); timer=setInterval(tick,1500);

/* =========================
   리스트/스파크(버튼 그대로)
   ========================= */
async function loadList(type){
  $('loader').style.display='inline-flex';
  try{
    const j=await (await fetch(`/api/list?type=${type}`)).json();
    fillTable(j.list||[], type);
  } finally{$('loader').style.display='none';}
}
async function loadSpark(history=false){
  $('loader').style.display='inline-flex';
  try{
    const j=await (await fetch('/api/spark')).json();
    fillTable(history ? (j.history||[]) : (j.list||[]), history?'spark-his':'spark');
  } finally{$('loader').style.display='none';}
}
function fillTable(arr, mode){
  const tb=document.querySelector("#listTable tbody"); tb.innerHTML="";
  arr.forEach(c=>{
    const name=c.name ?? c.market?.replace('KRW-','') ?? '-';
    const price=c.price ?? c.price_krw ?? 0;
    let changeCell, cls;
    if(mode==='spark' || mode==='spark-his'){
      changeCell=`${pct(c.deltaPct)} · Vx${(c.volRatio||0).toFixed(1)}${mode==='spark-his'&&c.at?` · ${new Date(c.at).toLocaleTimeString()}`:''}`;
      cls=c.deltaPct>=0?'green':'red';
    }else{
      changeCell=pct(c.change); cls=c.change>=0?'green':'red';
    }
    const tr=document.createElement("tr");
    tr.innerHTML=`<td>${name}</td><td>${fmtKRW(price)}</td><td class="${cls}">${changeCell}</td>`;
    tb.appendChild(tr);
  });
}
loadList('rising');
</script>
