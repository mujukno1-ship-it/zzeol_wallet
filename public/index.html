<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>사토시의지갑 v10.0 — 단일파일</title>
  <style>
    /* =============================
       사토시의지갑 v10.0 — 기본 스타일
       - KRW 기준, 업비트 호가틱, 한글 코인명, No‑Motion(화면 깜빡임 없음)
       - 상단 고정 검색창 + SPARK TOP10 고정 노출
       - 카드형 패널(현재가/매수/익절/손절/위험도/쩔어한마디)
       ============================= */
    :root {
      --bg: #0b0f14;
      --panel: #101722;
      --panel-2: #0f141c;
      --text: #e9eef7;
      --muted: #98a2b3;
      --up: #19c37d;
      --down: #ef4444;
      --accent: #60a5fa;
      --chip: #1b2432;
      --chip-border: #223049;
      --warn: #f59e0b;
      --danger: #ef4444;
      --ok: #22c55e;
    }
    * { box-sizing:border-box; }
    html, body { height:100%; }
    body {
      margin:0; background:var(--bg); color:var(--text);
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Apple SD Gothic Neo, "Noto Sans KR", sans-serif;
    }
    header {
      position:sticky; top:0; z-index:50; background:linear-gradient(180deg, rgba(11,15,20,0.95), rgba(11,15,20,0.8));
      backdrop-filter:saturate(120%) blur(8px);
      border-bottom:1px solid #162131;
    }
    .wrap { max-width:1200px; margin:0 auto; padding:10px 16px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .search {
      flex:1; display:flex; align-items:center; gap:10px; background:var(--panel);
      border:1px solid #1c2a41; padding:10px 12px; border-radius:12px;
    }
    .search input { flex:1; background:transparent; border:0; outline:none; color:var(--text); font-size:16px; }
    .api-badge { font-size:12px; color:var(--muted); }
    .hint { font-size:12px; color:var(--muted); }

    .grid { display:grid; grid-template-columns: 1.35fr 1fr; gap:16px; padding:16px; }
    @media (max-width: 980px){ .grid { grid-template-columns: 1fr; } }

    .card {
      background:var(--panel); border:1px solid #1c2a41; border-radius:16px; padding:14px; 
      box-shadow: 0 0 0 1px rgba(20,34,56,0.2) inset;
    }
    .card h3 { margin:0 0 8px; font-size:16px; color:#c6d4ea; font-weight:600; }

    /* SPARK TOP10 (No‑Motion: 높이 고정 + diff 패치) */
    #spark-list { display:grid; grid-template-columns: repeat(2, 1fr); gap:10px; }
    @media (max-width: 700px){ #spark-list { grid-template-columns: 1fr; } }
    .spark-item { display:flex; align-items:center; gap:10px; background:var(--panel-2); border:1px solid #1c2a41; padding:10px; border-radius:12px; cursor:pointer; }
    .spark-item:hover { border-color:#2a3a56; }
    .spark-name { font-weight:700; }
    .spark-gauge { margin-left:auto; display:flex; gap:8px; align-items:center; }
    .spark-bar { width:120px; height:8px; background:#111827; border-radius:999px; overflow:hidden; border:1px solid #1c2a41; }
    .spark-bar > span { display:block; height:100%; width:0%; background:linear-gradient(90deg, #f97316, #ef4444); }
    .spark-score { font-size:12px; color:#cbd5e1; }

    /* 시그널 패널 */
    .signal { display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; }
    @media (max-width: 700px){ .signal { grid-template-columns: 1fr; } }
    .metric { background:var(--panel-2); border:1px solid #1c2a41; border-radius:12px; padding:10px; }
    .metric .label { color:var(--muted); font-size:12px; margin-bottom:6px; }
    .metric .value { font-size:18px; font-weight:800; }
    .value.up { color:var(--up); } .value.down { color:var(--down); }

    .chips { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
    .chip { background:var(--chip); border:1px solid var(--chip-border); padding:6px 10px; border-radius:999px; font-size:12px; color:#cbd5e1; }

    .ment { margin-top:10px; background:#0e1420; border:1px dashed #25344f; padding:12px; border-radius:12px; color:#cfe5ff; line-height:1.35; }

    .muted { color:var(--muted); font-size:12px; }
    .hr { height:1px; background:#162131; margin:12px 0; }

    .footer { padding:14px 16px; color:#7c8aa5; font-size:12px; border-top:1px solid #162131; }
  </style>
</head>
<body>
  <!-- =============================
       메모리(사토시 v10.0) 핵심: KRW/업비트호가틱/한글/No‑Motion/검색고정/SPARK고정
       Precision Boost, SPARK, ForceIndex_AI, Bull/Bear Mode, Free Alpha Pack, AI Ment, 정확도 보정 ±0.3%
       ============================= -->
  <header>
    <div class="wrap">
      <div class="row">
        <div class="search" role="search">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#6b7280"><circle cx="11" cy="11" r="7"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
          <input id="search-input" placeholder="코인 검색 (한글명) — 예: 시바이누, 칠리즈, 온도, 네오…" />
          <span class="api-badge" id="api-badge">API: <span id="api-url"></span></span>
        </div>
        <div class="hint">KRW · 업비트 호가틱 · 한글 코인명 · No‑Motion</div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div class="grid">
      <!-- 좌측: SPARK TOP10 -->
      <section class="card" aria-label="SPARK TOP10">
        <h3>SPARK TOP10 — 급등 전 예열코인 🔥 (고정)</h3>
        <div id="spark-list" aria-live="polite"></div>
        <div class="hr"></div>
        <div class="muted">예열 조건: RVOL≥1.8 · TBR≥0.60 · OBI≥+0.15 · 최근5분 변동률≥+1.5% (4개 이상 충족 시 등록)</div>
      </section>

      <!-- 우측: 선택 코인 시그널 -->
      <section class="card" aria-label="ULTRA 시그널">
        <h3 id="signal-title">ULTRA 시그널 — 코인 선택 대기중</h3>
        <div class="signal" id="signal-metrics">
          <div class="metric"><div class="label">현재가</div><div class="value" id="v-price">—</div></div>
          <div class="metric"><div class="label">매수(BUY1)</div><div class="value" id="v-buy1">—</div></div>
          <div class="metric"><div class="label">추가매수(BUY2)</div><div class="value" id="v-buy2">—</div></div>
          <div class="metric"><div class="label">익절 1 (TP1)</div><div class="value" id="v-tp1">—</div></div>
          <div class="metric"><div class="label">익절 2 (TP2)</div><div class="value" id="v-tp2">—</div></div>
          <div class="metric"><div class="label">손절 (SL)</div><div class="value" id="v-sl">—</div></div>
        </div>
        <div class="chips" id="chips"></div>
        <div class="ment" id="ment">코인을 선택하면 쩔어한마디와 위험도·예열·세력지수가 표시됩니다.</div>
      </section>
    </div>
  </main>

  <div class="footer wrap">
    사토시의지갑 v10.0 • Precision Boost • ForceIndex_AI • Bull/Bear Mode • Free Alpha Pack • No‑Motion DOM Patch
  </div>

  <script>
  /* ==========================================================
     사토시의지갑 v10.0 — 단일 파일 스크립트
     - API_BASE: satoshi-proxy (무료 연동 기본)
     - KRW 기준 · 업비트 호가틱 반올림 · 한글 코인명 · No‑Motion
     - SPARK 예열 스코어 · ForceIndex_AI · Precision Boost · Bull/Bear
     - 파이프라인: applySignalBoost → Bull/Bear → FreeAlpha → adjustTP_SL → roundToUpbitTick
     ========================================================== */

  // ====== 0) 전역 설정 (메모리 최신판) ======
  const CONFIG = {
    API_BASE: 'https://satoshi-proxy.mujukno1.workers.dev/api',
    NO_MOTION: true,
    LOOP_MS: 5000,          // 5초 갱신 루프 (No‑Motion: diff patch)
    SPARK_TOP_N: 10,        // SPARK TOP10 고정
    PRECISION_EPS: 0.003,   // ±0.3% 자동 보정(Precision Boost)
  };
  document.getElementById('api-url').textContent = CONFIG.API_BASE;

  // ====== 1) 유틸 — 업비트 호가틱(틱) 규칙 & 반올림 ======
  function getUpbitTick(price){
    if (price < 0.1) return 0.001;
    if (price < 1) return 0.01;
    if (price < 10) return 0.1;
    if (price < 100) return 1;
    if (price < 1000) return 5;
    if (price < 10000) return 10;
    if (price < 100000) return 50;
    if (price < 500000) return 100;
    return 500;
  }
  function roundToUpbitTick(price){
    const t = getUpbitTick(price);
    return Math.round(price / t) * t;
  }
  function fmtKRW(n){
    if (n == null || isNaN(n)) return '—';
    const tick = getUpbitTick(Math.abs(n));
    const decimals = (tick < 1) ? (tick === 0.001 ? 3 : tick === 0.01 ? 2 : 1) : 0;
    return new Intl.NumberFormat('ko-KR', { minimumFractionDigits: decimals, maximumFractionDigits: decimals }).format(n) + '원';
  }

  // ====== 2) 코인 한글명 매핑 (예: API가 KRW-ETH → 이더리움 으로 제공 or 로컬 보정) ======
  // 필요 시 확장: 실제 API가 한글명 제공하면 그대로 사용. 없으면 아래 맵으로 보강.
  const KOREAN_NAME = {
    'KRW-SHIB': '시바이누', 'KRW-CHZ': '칠리즈', 'KRW-DOGE': '도지코인', 'KRW-NEO': '네오', 'KRW-ONG': '온톨로지가스',
    'KRW-ARB': '아비트럼', 'KRW-ENA': '에테나', 'KRW-ONDO':'온도', 'KRW-ETH': '이더리움', 'KRW-BTC': '비트코인'
  };
  function toKo(market){ return KOREAN_NAME[market] || market; }

  // ====== 3) 데이터 소스(Fetch) — 무료 연동 세트(업비트/김프/펀딩/온체인 등) 라우팅 ======
  async function fetchJSON(url){
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) throw new Error('HTTP '+r.status);
    return r.json();
  }

  // 예시 엔드포인트(워커에서 가공되어 나온다고 가정). 실제 워커 스펙에 맞춰 경로 조정해도 OK.
  const API = {
    tickers: () => fetchJSON(`${CONFIG.API_BASE}/upbit/tickers`), // [{market:"KRW-SHIB", tradePrice: 0.0375, changeRate: 0.012, ...}]
    orderStats: (market) => fetchJSON(`${CONFIG.API_BASE}/order/stats?market=${encodeURIComponent(market)}`), // {tbr:0.63, obi:0.18, microprice: ...}
    rvol: (market) => fetchJSON(`${CONFIG.API_BASE}/rvol?market=${encodeURIComponent(market)}&window=5m`), // {rvol:1.92}
    atr: (market) => fetchJSON(`${CONFIG.API_BASE}/atr?market=${encodeURIComponent(market)}&tf=1h`), // {atr:0.0012}
    spark5m: () => fetchJSON(`${CONFIG.API_BASE}/spark/top?window=5m&limit=${CONFIG.SPARK_TOP_N}`), // 스파크 점수 계산을 워커가 대신 해줄 수도 있음
    kimchi: () => fetchJSON(`${CONFIG.API_BASE}/kimchi`), // {premium:3.1}
    funding: (symbol) => fetchJSON(`${CONFIG.API_BASE}/deriv/funding?symbol=${encodeURIComponent(symbol)}`),
    stableflow: () => fetchJSON(`${CONFIG.API_BASE}/defillama/stableflow`),
    mempool: () => fetchJSON(`${CONFIG.API_BASE}/mempool`),
    fgi: () => fetchJSON(`${CONFIG.API_BASE}/feargreed`)
  };

  // ====== 4) 코어: SPARK 스코어 & ForceIndex_AI & 모드 판정 ======
  function computeSparkScore(v){
    // v = { rvol, tbr, obi, atrRank, force }
    const score = (v.rvol*0.30) + (v.tbr*0.25) + (v.obi*0.15) + (v.atrRank*0.15) + (v.force*0.15);
    return Math.max(0, Math.min(100, Math.round(score)));
  }
  function expectedRisePctBySpark(score){
    if (score >= 90) return [0.15, 0.25];
    if (score >= 80) return [0.08, 0.12];
    if (score >= 70) return [0.04, 0.06];
    return [0.0, 0.0];
  }
  function computeForceIndexAI(inp){
    // inp = { rvol, tbr, obi, micro, whale, stable, liqmap }
    // 간단 스코어러 (0~100): 입력 신호를 0~1 정규화 가정
    const w = { rvol:0.25, tbr:0.20, obi:0.15, micro:0.15, whale:0.10, stable:0.10, liqmap:0.05 };
    let s = 0;
    for (const k in w){ s += (inp[k] ?? 0) * w[k]; }
    return Math.max(0, Math.min(100, Math.round(s*100)));
  }
  function detectMode({ rvol, tbr, obi, force, vwapDiffATR, kimchi, basis, fundingNeg, whaleIn, closeBelowVWAP }){
    // 불장 모드 조건 (3개 이상)
    const bullHits = [ rvol>=2.0, tbr>=0.65, kimchi>=3.0, force>=80, vwapDiffATR>=1.5 ].filter(Boolean).length;
    if (bullHits >= 3) return 'BULL';
    // 하락장 빠른매도 조건
    const bearHits = [ rvol>=1.4 && closeBelowVWAP, tbr<=0.45, obi<=-0.2, force<=35, (basis<0||fundingNeg), whaleIn ].filter(Boolean).length;
    if (bearHits >= 3) return 'BEAR';
    return 'NEUTRAL';
  }

  // ====== 5) Precision Boost (±0.3% 자동 보정, 3회 루프) ======
  function precisionBoost(priceObj){
    // priceObj = { buy1, buy2, tp1, tp2, sl, current }
    const keys = ['buy1','buy2','tp1','tp2','sl'];
    for (let i=0;i<3;i++){
      for (const k of keys){
        const p = priceObj[k];
        const err = (p - roundToUpbitTick(p)) / (priceObj.current||1);
        if (Math.abs(err) > CONFIG.PRECISION_EPS){
          priceObj[k] = roundToUpbitTick(p);
        }
      }
    }
    return priceObj;
  }

  // ====== 6) 타점 계산 (엔진 파이프라인) ======
  function computeSignals({ C, VWAP, ATR, sparkScore, mode }){
    // BUY1/2 (세력 매집 구간 중심)
    let BUY1 = VWAP - 0.8*ATR;
    let BUY2 = VWAP - 1.2*ATR;

    // SPARK 기반 기대 상승률 → TP 폭 설정 힌트
    const [rMin, rMax] = expectedRisePctBySpark(sparkScore);
    const midRise = (rMin + rMax)/2;
    // 기본 TP/SL (중립)
    let TP1 = C + 1.2*ATR;
    let TP2 = C + 2.2*ATR;
    let SL  = C - 1.0*ATR;

    // 모드 보정
    if (mode === 'BULL'){
      TP1 = C + 1.6*ATR; TP2 = C + 2.8*ATR; SL = C - 0.8*ATR;
    } else if (mode === 'BEAR'){
      TP1 = C + 0.6*ATR; TP2 = C + 1.0*ATR; SL = C - 1.3*ATR; BUY2 = null; // 빠른매도: 추가매수 비활성
    } else {
      // 중립: SPARK 강도에 따라 완만 조정
      TP1 = C + (1.0 + midRise*2.0)*ATR; // 예: 0.10 → +1.2×ATR
      TP2 = C + (1.8 + midRise*2.5)*ATR;
    }

    // Precision Boost → 업비트 호가틱 반올림
    const out = precisionBoost({ current:C, buy1:BUY1, buy2:BUY2??undefined, tp1:TP1, tp2:TP2, sl:SL });
    out.buy1 = roundToUpbitTick(out.buy1);
    if (out.buy2!=null) out.buy2 = roundToUpbitTick(out.buy2);
    out.tp1  = roundToUpbitTick(out.tp1);
    out.tp2  = roundToUpbitTick(out.tp2);
    out.sl   = roundToUpbitTick(out.sl);

    return out;
  }

  // ====== 7) SPARK 리스트 렌더 (No‑Motion diff patch) ======
  const sparkEl = document.getElementById('spark-list');
  function renderSparkList(items){
    // items: [{market, koName, price, rvol, tbr, obi, atrRank, force, score, expectedRisePct, risingProb}]
    // No‑Motion: key=market 고정, DOM 교체 대신 내용만 패치
    const byKey = new Map();
    for (const child of sparkEl.children){ byKey.set(child.dataset.key, child); }

    const nextKeys = new Set(items.map(it => it.market));

    // 삭제 대상 제거 (최소 DOM 변경)
    for (const [key, node] of byKey.entries()){
      if (!nextKeys.has(key)) sparkEl.removeChild(node);
    }

    // 갱신/삽입
    for (const it of items){
      let node = byKey.get(it.market);
      const scoreColor = it.score>=90 ? '#ef4444' : it.score>=80 ? '#f97316' : '#9ca3af';
      const gauge = Math.max(0, Math.min(100, it.score));
      if (!node){
        node = document.createElement('div');
        node.className = 'spark-item';
        node.dataset.key = it.market;
        node.innerHTML = `
          <div class="spark-name"></div>
          <div class="spark-price muted"></div>
          <div class="spark-gauge">
            <div class="spark-bar"><span></span></div>
            <div class="spark-score"></div>
          </div>`;
        node.addEventListener('click', () => selectMarket(it.market));
        sparkEl.appendChild(node);
      }
      node.querySelector('.spark-name').textContent = `${toKo(it.market)} (${it.market.replace('KRW-','')})`;
      node.querySelector('.spark-price').textContent = fmtKRW(it.price);
      node.querySelector('.spark-bar > span').style.width = gauge + '%';
      node.querySelector('.spark-bar > span').style.background = gauge>=90? 'linear-gradient(90deg,#ef4444,#dc2626)': gauge>=80? 'linear-gradient(90deg,#f59e0b,#ef4444)' : 'linear-gradient(90deg,#6b7280,#9ca3af)';
      node.querySelector('.spark-score').textContent = `SPARK ${it.score}`;
      node.querySelector('.spark-score').style.color = scoreColor;
    }
  }

  // ====== 8) 선택 코인 시그널 표시 ======
  async function selectMarket(market){
    try{
      currentMarket = market;
      document.getElementById('signal-title').textContent = `ULTRA 시그널 — ${toKo(market)} (${market.replace('KRW-','')})`;

      // 병렬 조회
      const [stats, rv, atr] = await Promise.all([
        API.orderStats(market).catch(()=>({ tbr:0.5, obi:0, micro:0.5 })),
        API.rvol(market).catch(()=>({ rvol:1 })),
        API.atr(market).catch(()=>({ atr: 0.01 }))
      ]);

      // 현재가는 전체 틱커에서 사용 (캐시)
      const C = (lastTickers.find(t => t.market===market)?.tradePrice) ?? null;
      const VWAP = (lastTickers.find(t => t.market===market)?.vwap) ?? C;
      const ATR = atr.atr || 0.01;

      // ForceIndex_AI 추정값 계산
      const force = computeForceIndexAI({
        rvol: normalize(rv.rvol, 0, 3.0),
        tbr:  normalize(stats.tbr, 0, 1),
        obi:  normalize(stats.obi, -0.5, 0.5),
        micro:normalize(stats.micro, 0, 1),
        whale: 0.5, stable: 0.5, liqmap: 0.5 // 외부 연동값은 워커에서 보강
      });

      const atrRank = 0.75; // 예시: 상위 25%
      const sparkScore = computeSparkScore({ rvol:rv.rvol||1, tbr:stats.tbr||0.5, obi:stats.obi||0, atrRank, force:force/100 });
      // 모드 판정 (김프/펀딩 등은 워커에서 제공 가능)
      const mode = detectMode({ rvol:rv.rvol||1, tbr:stats.tbr||0.5, obi:stats.obi||0, force:force, vwapDiffATR: (C&&VWAP&&ATR)? ((C - VWAP)/ATR) : 0, kimchi: 3.0, basis: 0, fundingNeg: false, whaleIn:false, closeBelowVWAP: C<VWAP });

      const out = computeSignals({ C, VWAP, ATR, sparkScore, mode });

      // 렌더 (No‑Motion: 텍스트만 갱신)
      patchText('v-price', fmtKRW(roundToUpbitTick(C)));
      patchText('v-buy1', out.buy1!=null? fmtKRW(out.buy1): '—');
      patchText('v-buy2', out.buy2!=null? fmtKRW(out.buy2): '—');
      patchText('v-tp1', fmtKRW(out.tp1));
      patchText('v-tp2', fmtKRW(out.tp2));
      patchText('v-sl',  fmtKRW(out.sl));

      // 칩 + 쩔어한마디
      renderChips({ sparkScore, force, mode, rv:rv.rvol||1, tbr:stats.tbr||0.5 });
      renderMent({ sparkScore, force, mode });
    } catch(e){ console.error(e); }
  }

  function renderChips({ sparkScore, force, mode, rv, tbr }){
    const el = document.getElementById('chips');
    el.innerHTML = '';
    const mk = (t)=>{ const s=document.createElement('div'); s.className='chip'; s.textContent=t; return s; };
    el.appendChild(mk(`예열강도 ${sparkScore}`));
    el.appendChild(mk(`세력지수 ${force}`));
    el.appendChild(mk(`체결강도 ${Math.round((tbr||0)*100)}%`));
    el.appendChild(mk(mode==='BULL'?'불장 모드🔥': mode==='BEAR'?'하락장 빠른매도⚠':'중립 모드'));
  }

  function renderMent({ sparkScore, force, mode }){
    const m = document.getElementById('ment');
    let text = '';
    if (mode==='BULL'){
      text = `🔥 세력 분출 직전 — 예열강도 ${sparkScore} / 세력강도 ${force}% / 불장 모드: 익절 지연, SL 완화 (TP1=C+1.6×ATR, TP2=C+2.8×ATR, SL=C−0.8×ATR)`;
    } else if (mode==='BEAR'){
      text = `⚠ 세력 이탈 감지 — 예열강도 ${sparkScore} / 세력강도 ${force}% / 하락장 빠른매도: TP 짧게, SL 강화 (TP1=C+0.6×ATR, TP2=C+1.0×ATR, SL=C−1.3×ATR)`;
    } else {
      const prob = sparkScore>=90? 88: sparkScore>=80? 78: sparkScore>=70? 68: 50;
      const rise = sparkScore>=90? 21.6: sparkScore>=80? 10.2: sparkScore>=70? 5.3: 0.0;
      text = `🔵 조정/대기 — 예열강도 ${sparkScore} / 상승확률 ${prob}% / 예상상승률 +${rise}%`;
    }
    patchText('ment', text);
  }

  function patchText(id, text){
    const el = document.getElementById(id);
    if (!el) return;
    if (el.textContent !== text){ el.textContent = text; }
  }
  function normalize(v, min, max){ if (v==null) return 0; return Math.max(0, Math.min(1, (v-min)/(max-min))); }

  // ====== 9) 데이터 루프 (SPARK TOP10) ======
  let currentMarket = null;
  let lastTickers = [];

  async function loop(){
    try{
      // 1) 틱커 + SPARK 소스
      const [tickers, spark] = await Promise.all([
        API.tickers().catch(()=>[]),
        API.spark5m().catch(()=>null)
      ]);
      lastTickers = tickers || [];

      let sparkItems = [];
      if (spark && Array.isArray(spark) && spark.length){
        // 워커가 이미 계산해준 경우
        sparkItems = spark.slice(0, CONFIG.SPARK_TOP_N).map(s => ({
          market: s.market,
          koName: toKo(s.market),
          price: s.price,
          rvol: s.rvol, tbr: s.tbr, obi: s.obi, atrRank: s.atrRank, force: s.force,
          score: s.score,
        }));
      } else {
        // 로컬 계산 (예: 틱커 상위 거래대금 종목 중 샘플)
        const sample = (tickers||[]).filter(t => (t.market||'').startsWith('KRW-')).slice(0, 20);
        sparkItems = await Promise.all(sample.map(async t => {
          const [stats, rv] = await Promise.all([
            API.orderStats(t.market).catch(()=>({ tbr:0.5, obi:0 })),
            API.rvol(t.market).catch(()=>({ rvol:1 }))
          ]);
          const atrRank = Math.random()*0.5 + 0.5; // 0.5~1.0 가정
          const force = computeForceIndexAI({
            rvol: normalize(rv.rvol, 0, 3.0), tbr: normalize(stats.tbr,0,1), obi: normalize(stats.obi,-0.5,0.5),
            micro:0.5, whale:0.5, stable:0.5, liqmap:0.5
          })/100;
          const score = computeSparkScore({ rvol:rv.rvol||1, tbr:stats.tbr||0.5, obi:stats.obi||0, atrRank, force });
          return { market:t.market, koName:toKo(t.market), price:t.tradePrice, rvol:rv.rvol, tbr:stats.tbr, obi:stats.obi, atrRank, force, score };
        }));
        sparkItems.sort((a,b)=> b.score - a.score);
        sparkItems = sparkItems.slice(0, CONFIG.SPARK_TOP_N);
      }

      renderSparkList(sparkItems);

      // 선택된 코인이 없으면 1위 자동 선택 (No‑Motion 유지)
      if (!currentMarket && sparkItems[0]){
        selectMarket(sparkItems[0].market);
      }
    } catch(err){ console.error(err); }
  }

  // 검색 이벤트 (한글명 포함)
  document.getElementById('search-input').addEventListener('keydown', (e)=>{
    if (e.key === 'Enter'){
      const q = e.target.value.trim();
      if (!q) return;
      // 간단 검색: 한글명 매칭 or 심볼 매칭
      // 실제로는 워커에 /search?query= 로 위임 가능
      const hit = lastTickers.find(t => toKo(t.market).includes(q) || (t.market||'').includes(q.toUpperCase()));
      if (hit){ selectMarket(hit.market); }
    }
  });

  // 시작
  loop();
  setInterval(loop, CONFIG.LOOP_MS);

  </script>
</body>
</html>
