<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>쩔어지갑 — BTC 통합칩 + 정확도 스파크라인</title>
  <style>
    body{background:#0f1419;color:#e6edf3;font-family:Pretendard,system-ui,Segoe UI,Roboto,sans-serif;margin:0;padding:20px}
    .card{background:#151b22;border:1px solid #2a3545;border-radius:14px;padding:16px;margin-bottom:16px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .chip{padding:6px 12px;border-radius:999px;font-weight:600;font-size:14px;display:inline-flex;align-items:center;gap:6px;border:1px solid #2a3545}
    .chip.green{background:#0f2417;color:#7ce4af;border-color:#175e3d}
    .chip.yellow{background:#2c2a0f;color:#e4da7c;border-color:#5c5517}
    .chip.red{background:#2c0f0f;color:#e47c7c;border-color:#5e1717}
    #spark{width:200px;height:60px}
  </style>
</head>
<body>
  <div class="card">
    <div class="row">
      <h2>BTC 통합칩 (정확도 + 위험도 + 추세)</h2>
      <button id="btnRefresh" style="margin-left:auto;padding:8px 12px;border-radius:8px;background:#1f2d44;color:#e6edf3;border:1px solid #284161">즉시 갱신</button>
    </div>
    <div class="row" style="margin-top:8px">
      <div id="chipAccuracy" class="chip green">정확도: 92%</div>
      <div id="chipRisk" class="chip yellow">위험도: 보통</div>
      <div id="chipTrend" class="chip green">추세: 상승</div>
    </div>
    <canvas id="spark"></canvas>
  </div>

  <!-- AI 예측 타점 (1H · 4H · Daily) -->
  <div class="card">
    <div class="row">
      <h2>AI 예측 타점 — 1H · 4H · Daily</h2>
      <button id="btnTF" style="margin-left:auto;padding:8px 12px;border-radius:8px;background:#1f2d44;color:#e6edf3;border:1px solid #284161">타임프레임 갱신</button>
    </div>
    <div style="overflow:auto;margin-top:8px">
      <table style="width:100%;border-collapse:separate;border-spacing:0">
        <thead>
          <tr style="color:#9fb0c0;text-transform:uppercase;font-size:12px">
            <th>TF</th>
            <th>신호</th>
            <th>현재가</th>
            <th>ATR(14)</th>
            <th>정확도</th>
            <th>신뢰도</th>
            <th>매수(진입)</th>
            <th>TP1</th>
            <th>TP2</th>
            <th>손절</th>
            <th>근거</th>
          </tr>
        </thead>
        <tbody id="tfBody"></tbody>
      </table>
    </div>
  </div>

  <script>
    const $ = s=>document.querySelector(s);
    const ctx = document.createElement('canvas').getContext;

    let accuracyHistory = [];

    async function fetchBTC(){
      try{
        const upbit = await fetch('https://api.upbit.com/v1/ticker?markets=KRW-BTC').then(r=>r.json());
        const upPrice = upbit[0].trade_price;
        const b = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT').then(r=>r.json());
        const binance = parseFloat(b.price);
        const xr = await fetch('https://api.exchangerate.host/latest?base=USD&symbols=KRW').then(r=>r.json());
        const usdkrw = xr.rates.KRW;
        const kimchi = (upPrice/(binance*usdkrw)-1)*100;
        const fr = await fetch('https://fapi.binance.com/fapi/v1/premiumIndex?symbol=BTCUSDT').then(r=>r.json());
        const funding = parseFloat(fr.lastFundingRate)*100;
        const kl = await fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&limit=200').then(r=>r.json());
        const close = kl.map(k=>parseFloat(k[4]));
        const high = kl.map(k=>parseFloat(k[2]));
        const low  = kl.map(k=>parseFloat(k[3]));
        function ema(a,p){const k=2/(p+1);let e=a[0];const out=[e];for(let i=1;i<a.length;i++){e=a[i]*k+e*(1-k);out.push(e);}return out;}
        function atr14(){const tr=[];for(let i=1;i<high.length;i++){const h=high[i],l=low[i],pc=close[i-1];tr.push(Math.max(h-l,Math.abs(h-pc),Math.abs(l-pc)));}let atr=tr.slice(0,14).reduce((a,b)=>a+b,0)/14;for(let i=14;i<tr.length;i++){atr=(atr*13+tr[i])/14;}return atr;}
        const c=close.at(-1), e20=ema(close,20).at(-1), e50=ema(close,50).at(-1), atr=atr14();
        const trend=(c>e20&&e20>e50)?'상승':(c<e20&&e20<e50)?'하락':'횡보';

        let penalty=0;
        if(trend==='횡보') penalty+=20;
        if(Math.abs(kimchi)>5) penalty+=10;
        if(Math.abs(funding)>0.05) penalty+=5;
        if(atr/c>0.015) penalty+=10;
        const accuracy=Math.max(50,100-penalty);
        const risk=(accuracy>80?'낮음':accuracy>70?'보통':'높음');

        // update chips
        const accChip=$('#chipAccuracy');
        accChip.textContent=`정확도: ${accuracy.toFixed(1)}%`;
        accChip.className='chip '+(accuracy>80?'green':accuracy>70?'yellow':'red');
        const riskChip=$('#chipRisk');
        riskChip.textContent=`위험도: ${risk}`;
        riskChip.className='chip '+(risk==='낮음'?'green':risk==='보통'?'yellow':'red');
        const trendChip=$('#chipTrend');
        trendChip.textContent=`추세: ${trend}`;
        trendChip.className='chip '+(trend==='상승'?'green':trend==='하락'?'red':'yellow');

        accuracyHistory.push(accuracy);
        if(accuracyHistory.length>24) accuracyHistory.shift();
        drawSpark();
      }catch(e){console.error(e);}
    }

    function drawSpark(){
      const c=document.querySelector('#spark');
      const ctx=c.getContext('2d');
      const w=c.width=c.offsetWidth; const h=c.height=c.offsetHeight;
      ctx.clearRect(0,0,w,h);
      if(accuracyHistory.length<2) return;
      const max=Math.max(...accuracyHistory), min=Math.min(...accuracyHistory);
      ctx.beginPath();
      accuracyHistory.forEach((v,i)=>{
        const x=i/(accuracyHistory.length-1)*w;
        const y=h-(v-min)/(max-min+1e-6)*h;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.strokeStyle='#2b8cff';
      ctx.lineWidth=2;
      ctx.stroke();
    }

    $('#btnRefresh').onclick=fetchBTC;
    fetchBTC();
    setInterval(fetchBTC,60000);

    // ===== AI 예측 타점 계산 (1H, 4H, 1D) =====
    const tfMap = {
      '1H':'1h', '4H':'4h', '1D':'1d'
    };

    function wilderATR(high, low, close){
      const tr=[]; for(let i=1;i<high.length;i++){
        const h=high[i], l=low[i], pc=close[i-1];
        tr.push(Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc)));
      }
      const p=14; let atr = tr.slice(0,p).reduce((a,b)=>a+b,0)/p;
      for(let i=p;i<tr.length;i++){ atr = (atr*(p-1)+tr[i])/p; }
      return atr;
    }
    function ema(arr,p){ const k=2/(p+1); let e=arr[0]; for(let i=1;i<arr.length;i++){ e = arr[i]*k + e*(1-k);} return e; }

    function calcAccuracy({trend, kimchi, funding, atr, price}){
      let penalty = 0;
      if(trend==='횡보') penalty += 20;
      if(Math.abs(kimchi)>5) penalty += 10;
      if(Math.abs(funding)>0.05) penalty += 5;
      if(atr/price>0.015) penalty += 10;
      return Math.max(50, 100 - penalty);
    }

    function confFromAcc(a){ return a>80?'높음':a>70?'보통':'낮음'; }

    function rowHTML({label, signal, price, atr, acc, conf, tp1, tp2, sl, why}){
      const cls = acc>80?'#7ce4af':(acc>70?'#e4da7c':'#e47c7c');
      return `<tr>
        <td><b>${label}</b></td>
        <td>${signal}</td>
        <td style="text-align:right">${price.toFixed(2)}</td>
        <td style="text-align:right">${atr.toFixed(2)}</td>
        <td style="text-align:right;color:${cls}"><b>${acc.toFixed(1)}%</b></td>
        <td>${conf}</td>
        <td style="text-align:right"><b>${price.toFixed(2)}</b></td>
        <td style="text-align:right">${tp1.toFixed(2)}</td>
        <td style="text-align:right">${tp2.toFixed(2)}</td>
        <td style="text-align:right">${sl.toFixed(2)}</td>
        <td style="color:#9fb0c0">${why}</td>
      </tr>`;
    }

    async function fetchTF(interval){
      const kl = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${interval}&limit=200`).then(r=>r.json());
      const close = kl.map(k=>parseFloat(k[4]));
      const high  = kl.map(k=>parseFloat(k[2]));
      const low   = kl.map(k=>parseFloat(k[3]));
      const price = close.at(-1);
      const e20 = (function(){ const k=2/(20+1); let e=close[0]; for(let i=1;i<close.length;i++){ e = close[i]*k + e*(1-k);} return e; })();
      const e50 = (function(){ const k=2/(50+1); let e=close[0]; for(let i=1;i<close.length;i++){ e = close[i]*k + e*(1-k);} return e; })();
      const atr = wilderATR(high, low, close);
      const trend = (price>e20&&e20>e50)?'상승':(price<e20&&e20<e50)?'하락':'횡보';
      // 외부 공용 지표는 fetchBTC()에서 최신으로 채운다
      const upbit = await fetch('https://api.upbit.com/v1/ticker?markets=KRW-BTC').then(r=>r.json());
      const upPrice = upbit[0].trade_price;
      const b = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT').then(r=>r.json());
      const binance = parseFloat(b.price);
      const xr = await fetch('https://api.exchangerate.host/latest?base=USD&symbols=KRW').then(r=>r.json());
      const usdkrw = xr.rates.KRW;
      const kimchi = (upPrice/(binance*usdkrw)-1)*100;
      const fr = await fetch('https://fapi.binance.com/fapi/v1/premiumIndex?symbol=BTCUSDT').then(r=>r.json());
      const funding = parseFloat(fr.lastFundingRate)*100;

      const signal = trend==='상승'?'롱(매수 우위)':trend==='하락'?'숏(매도 우위)':'관망';
      const entry = price;
      const dir = (trend==='상승')?+1:(trend==='하락')?-1:0;
      const tp1 = entry + dir*0.5*atr;
      const tp2 = entry + dir*1.0*atr;
      const sl  = entry - dir*1.0*atr;
      const acc = calcAccuracy({trend, kimchi, funding, atr, price});
      const conf = confFromAcc(acc);
      const why = `EMA20/50, ATR14, 김프 ${(kimchi>=0?'+':'')}${kimchi.toFixed(2)}%, 펀딩 ${(funding>=0?'+':'')}${funding.toFixed(4)}%`;

      return {price, atr, signal, entry, tp1, tp2, sl, acc, conf, trend, kimchi, funding, why};
    }

    async function updateTF(){
      try{
        const tbody = document.querySelector('#tfBody');
        tbody.innerHTML = '';
        const rows = [];
        const oneH = await fetchTF('1h'); rows.push({label:'1H', ...oneH});
        const fourH = await fetchTF('4h'); rows.push({label:'4H', ...fourH});
        const oneD = await fetchTF('1d'); rows.push({label:'1D', ...oneD});
        rows.forEach(r=>{ tbody.insertAdjacentHTML('beforeend', rowHTML(r)); });
      }catch(e){ console.error(e); }
    }

    document.querySelector('#btnTF').onclick = updateTF;
    // 첫 로드에 계산
    updateTF();
  </script>
</body>
</html>
