<script>
/* ========= Upbit 호가단위 규칙 + 반올림 ========= */
function upbitTick(price){
  if (price >= 2000000) return 1000;
  if (price >= 1000000) return 500;
  if (price >=  500000) return 100;
  if (price >=  100000) return 50;
  if (price >=   10000) return 10;
  if (price >=    1000) return 1;
  if (price >=     100) return 0.1;
  if (price >=      10) return 0.01;
  return 0.001;
}
function roundToTick(price, mode="round"){
  const t = upbitTick(price);
  if (t === 0) return price;
  if (mode === "ceil")  return Math.ceil (price / t) * t;
  if (mode === "floor") return Math.floor(price / t) * t;
  return Math.round(price / t) * t;
}

/* ========= 공용 fetch ========= */
async function jfetch(url){
  try{
    const r = await fetch(url, { cache: "no-store" });
    if(!r.ok) throw new Error(await r.text());
    return await r.json();
  }catch(e){
    console.error("[fetch error]", url, e);
    return null;
  }
}

/* ========= 업비트와 동일한 현재가 산출 (ticker + orderbook 동기화) ========= */
async function getUpbitExactPrice(market){
  const [ticker, ob] = await Promise.all([
    jfetch(`/api/ticker?markets=${market}`),
    jfetch(`/api/orderbook?markets=${market}`)
  ]);

  let tradePrice = null;
  if (Array.isArray(ticker) && ticker.length){
    tradePrice = Number(ticker[0].trade_price);
  }

  let ask1=null,bid1=null;
  // 서버에서 리턴 형태가 { orderbook_units:[...] } 또는 업비트 원본 배열 둘 다 지원
  if (ob && Array.isArray(ob.orderbook_units) && ob.orderbook_units.length){
    ask1 = Number(ob.orderbook_units[0].ask_price);
    bid1 = Number(ob.orderbook_units[0].bid_price);
  } else if (Array.isArray(ob) && ob.length){
    const units = ob[0]?.orderbook_units || [];
    if (units.length){
      ask1 = Number(units[0].ask_price);
      bid1 = Number(units[0].bid_price);
    }
  }

  if (tradePrice != null) return roundToTick(tradePrice, "round");
  if (ask1!=null && bid1!=null) return roundToTick((ask1+bid1)/2, "round");
  return null;
}

/* ========= DOM 반영 (id=price / ask1 / bid1 사용) ========= */
async function updatePricePanel(market){
  const price = await getUpbitExactPrice(market);
  const el = document.querySelector("#price");
  if (el){
    el.textContent = (price!=null) ? price.toLocaleString("ko-KR") : "-";
  }
}
async function updateBestQuotes(market){
  const ob = await jfetch(`/api/orderbook?markets=${market}`);
  let ask1=null,bid1=null;
  if (ob && Array.isArray(ob.orderbook_units) && ob.orderbook_units.length){
    ask1 = Number(ob.orderbook_units[0].ask_price);
    bid1 = Number(ob.orderbook_units[0].bid_price);
  } else if (Array.isArray(ob) && ob.length){
    const units = ob[0]?.orderbook_units || [];
    if (units.length){
      ask1 = Number(units[0].ask_price);
      bid1 = Number(units[0].bid_price);
    }
  }
  const $ask = document.querySelector("#ask1");
  const $bid = document.querySelector("#bid1");
  if ($ask) $ask.textContent = (ask1!=null) ? roundToTick(ask1).toLocaleString("ko-KR") : "-";
  if ($bid) $bid.textContent = (bid1!=null) ? roundToTick(bid1).toLocaleString("ko-KR") : "-";
}

/* ========= 주기 갱신 ========= */
let _syncTimer = null;
function startUpbitSync(market){
  clearInterval(_syncTimer);
  const work = () => { updatePricePanel(market); updateBestQuotes(market); };
  work();
  _syncTimer = setInterval(work, 2000);
}

/* ========= 최초 실행: 기본 SHIB로 시작 (원하면 바꾸세요) ========= */
document.addEventListener("DOMContentLoaded", () => {
  // 기본: KRW-SHIB
  startUpbitSync("KRW-SHIB");
});

/* ========= (선택) 코인 선택 시 동기화 재시작 헬퍼 =========
   예: 코인을 바꿀 때 startUpbitSync("KRW-ETH") 처럼 호출만 해주면 끝.
   아래 함수는 전역으로 둬서 기존 선택 로직에서 쉽게 호출 가능.
*/
window.setMarketAndSync = (market) => startUpbitSync(market);
</script>
