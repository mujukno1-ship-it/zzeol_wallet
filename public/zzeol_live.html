<!-- ====== zzeol_live.html : ONE-SHOT PATCH (paste above </body>) ====== -->
<script>
(() => {
  /* ====== 설정 ====== */
  const CFG = {
    API_BASE: '/upbit',         // Flask/서버 프록시 경로 (예: /upbit/ticker, /upbit/market/all)
    AUTO_MODE: false,           // true면 자동 분석 모드 기본 ON
    AUTO_INTERVAL_MS: 60_000,   // 자동 분석 간격(1분)
    TABLE_SEL: 'table',         // KRW 코인 목록 테이블 선택자 (필요시 구체화)
  };

  /* ====== 유틸 ====== */
  const $ = (s, r=document) => r.querySelector(s);
  const $$ = (s, r=document) => [...r.querySelectorAll(s)];
  const put = (sel, val) => { const el = $(sel); if (el) el.textContent = (val ?? '-'); };
  const safe = (v, d='-') => (v===undefined || v===null || v==='') ? d : v;
  const badge = (ok, msgOK='정상 연결', msgERR='연결 실패') => {
    const t = msgOK && ok ? msgOK : msgERR;
    const host = document.querySelector('[data-conn-badge]') || (()=>{
      const hb = document.createElement('span');
      hb.setAttribute('data-conn-badge','');
      hb.style.marginLeft='10px';
      hb.style.padding='2px 8px';
      hb.style.borderRadius='10px';
      hb.style.fontSize='12px';
      hb.style.verticalAlign='middle';
      (document.querySelector('.brand')||document.body).appendChild(hb);
      return hb;
    })();
    host.textContent = t;
    host.style.background = ok ? '#143f2b' : '#4a1d19';
    host.style.color = ok ? '#35d399' : '#ff8a8a';
  };
  const toast = (msg, ok=false) => {
    console[ok?'log':'warn']('[알림]', msg);
  };

  /* ====== 선택 행 하이라이트 CSS(없으면 주입) ====== */
  (function ensureRowCSS(){
    if ($('#__rowcss')) return;
    const st = document.createElement('style');
    st.id='__rowcss';
    st.textContent = `
      tr.selected { outline:2px solid rgba(80,200,255,.6); background: rgba(80,200,255,.06)!important; }
      .pill-toggle { cursor:pointer; font-size:12px; border:1px solid var(--line,#2b2b2b); padding:2px 8px; border-radius:999px; }
      .pill-toggle.on { background:rgba(80,200,255,.1) }
    `;
    document.head.appendChild(st);
  })();

  /* ====== 기존 함수가 있으면 그대로 사용 ====== */
  const callIfExists = (fnName, ...args) => {
    if (typeof window[fnName] === 'function') return window[fnName](...args);
    return undefined;
  };

  /* ====== API ====== */
  async function fetchMarketsKRW() {
    // 우선 기존 로더가 있으면 사용
    const existed = callIfExists('loadMarkets');
    if (existed) return existed;

    // 백엔드 프록시(Flask) 기준: /upbit/market/all?isDetails=true
    const url = `${CFG.API_BASE}/market/all?isDetails=true`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`시장목록 HTTP ${res.status}`);
    return res.json();
  }
  async function fetchTickerKRW(symbols) {
    // 기존 로더 있으면 사용
    const existed = callIfExists('loadTicker', symbols);
    if (existed) return existed;

    // symbols: ["KRW-BTC","KRW-ETH"...]
    const url = `${CFG.API_BASE}/ticker?markets=${encodeURIComponent(symbols.join(','))}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`티커 HTTP ${res.status}`);
    return res.json();
  }

  /* ====== 간단 신호(기본값) — 기존 compute 함수 없을 때만 사용 ====== */
  function fallbackSignals({ price, atr=0 }) {
    // 예시: ATR 배수 목표 + 단순 위험등급
    const atr1 = atr || Math.max(price*0.01, 10);   // ATR 추정(없으면 1% 대충)
    const buy = [
      `분할매수1: ${Math.round(price * 0.985)}`,
      `분할매수2: ${Math.round(price * 0.97)}`,
      `분할매수3: ${Math.round(price * 0.955)}`,
    ];
    const sell = [
      `TP1(ATR×1.0): ${Math.round(price + atr1*1.0)}`,
      `TP2(ATR×1.6): ${Math.round(price + atr1*1.6)}`,
      `TP3(ATR×2.2): ${Math.round(price + atr1*2.2)}`,
    ];
    const riskScore = (atr1 / Math.max(price,1)) * 100; // 단순 비율
    let risk = '낮음'; if (riskScore>1.5) risk='중간'; if (riskScore>3) risk='높음';
    const oneLiner = risk==='높음' ? '변동성 ↑ — 무리한 진입 자제'
                   : risk==='중간' ? '추세 확인 후 분할 진입'
                   : '완만 — 신중 분할 매수';
    return { buy, sell, risk, oneLiner };
  }

  /* ====== 렌더 ====== */
  function renderSignals({name,symbol,price,change,vol}, signals){
    // 상단 카드 채우기 (프로젝트 DOM에 맞춰 유연한 선택자 사용)
    put('[data-field="name"]', name || symbol || '-');
    put('[data-field="symbol"]', symbol || '-');
    put('[data-field="price"]', safe(price));
    put('[data-field="change"]', safe(change));
    put('[data-field="vol"]', safe(vol));

    // 매수/매도/위험도/쩔어한마디(존재하면 넣음)
    const buyBox = $('[data-box="buy"]') || $('#buy-box');
    const sellBox = $('[data-box="sell"]') || $('#sell-box');
    const riskEl  = $('[data-field="risk"]') || $('#risk');
    const oneEl   = $('[data-field="one-liner"]') || $('#one-liner');

    if (buyBox) buyBox.innerHTML = signals.buy.map(x=>`<div>• ${x}</div>`).join('');
    if (sellBox) sellBox.innerHTML = signals.sell.map(x=>`<div>• ${x}</div>`).join('');
    if (riskEl)  riskEl.textContent = signals.risk;
    if (oneEl)   oneEl.textContent  = signals.oneLiner;
  }

  /* ====== 메인: 코인 선택 시 호출 ====== */
  async function analyzeSymbol(rawSym){
    try{
      badge(true, '정상 연결');
      // “KRW-” 접두사 보정
      const sym = rawSym.startsWith('KRW-') ? rawSym : `KRW-${rawSym}`;
      // 기존 상세 분석기가 있으면 최우선 호출
      const used = callIfExists('loadSymbolDetails', sym);
      if (used !== undefined) return;

      // 대체 로직: 티커 불러와서 간단 분석
      const tk = await fetchTickerKRW([sym]);
      const t = tk?.[0];
      if(!t){ throw new Error('티커 데이터 없음'); }

      const price = Math.round(t.trade_price ?? t.acc_trade_price ?? 0);
      const changeRate = t.signed_change_rate ? (t.signed_change_rate*100).toFixed(2)+'%' : '-';
      const vol24 = t.acc_trade_price_24h ? Math.round(t.acc_trade_price_24h).toLocaleString()+'원' : '-';

      // ATR/EMA 등이 이미 프로젝트에 계산됨 → 그걸 사용
      let signals;
      const precomputed = callIfExists('computeAndRender', {symbol:sym, price});
      if (precomputed && precomputed.buy && precomputed.sell) {
        signals = precomputed;
      } else {
        // 없으면 기본 신호
        signals = fallbackSignals({ price });
      }

      const name = sym.replace('KRW-','');
      renderSignals({name, symbol:sym, price, change:changeRate, vol:vol24}, signals);

    }catch(err){
      badge(false, '연결 실패');
      toast(`분석 오류: ${err.message}`);
      console.error(err);
    }
  }

  /* ====== 리스트 행 클릭 연결 ====== */
  function wireTable(){
    const table = document.querySelector(CFG.TABLE_SEL);
    if(!table){ console.warn('[패치] 코인 리스트 테이블을 찾지 못했습니다.'); return;}
    // 클릭
    table.addEventListener('click', (e)=>{
      const tr = e.target.closest('tr');
      if(!tr) return;
      // 심볼 추출: data-symbol → 첫/둘째 셀
      const sym =
        tr.dataset?.symbol || tr.dataset?.ticker ||
        tr.cells?.[0]?.innerText || tr.cells?.1?.innerText || '';
      const clean = sym.replace(/[^\w\-]/g,'').trim();
      if(!clean) { toast('행에서 심볼을 찾지 못했습니다.'); return; }
      // 하이라이트
      table.querySelectorAll('tr.selected').forEach(x=>x.classList.remove('selected'));
      tr.classList.add('selected');
      // 분석
      analyzeSymbol(clean);
    });

    // 초기 자동 선택
    const first = table.querySelector('tbody tr, tr');
    if(first){
      first.dispatchEvent(new Event('click',{bubbles:true}));
    }
  }

  /* ====== 자동 분석 모드 토글 버튼 ====== */
  function mountAutoToggle(){
    const holder = document.querySelector('.brand') || document.body;
    const btn = document.createElement('button');
    btn.className='pill-toggle';
    btn.textContent='자동분석 OFF';
    btn.style.marginLeft='6px';
    holder.appendChild(btn);

    let on = (localStorage.getItem('AUTO_MODE') === '1') || CFG.AUTO_MODE;
    let timer = null;
    const sync = ()=>{
      btn.classList.toggle('on', on);
      btn.textContent = on ? '자동분석 ON' : '자동분석 OFF';
      localStorage.setItem('AUTO_MODE', on ? '1' : '0');
      if(timer) { clearInterval(timer); timer = null; }
      if(on){
        timer = setInterval(()=>{
          const sel = document.querySelector(`${CFG.TABLE_SEL} tr.selected`);
          const sym = sel?.dataset?.symbol || sel?.cells?.[0]?.innerText;
          if(sym) analyzeSymbol(sym);
        }, CFG.AUTO_INTERVAL_MS);
      }
    };
    btn.addEventListener('click', ()=>{ on = !on; sync(); });
    sync();
  }

  /* ====== 초기 구성 ====== */
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      // 시장 로딩 시도(연결상태 뱃지)
      await fetchMarketsKRW();
      badge(true, '정상 연결');
    } catch (e) {
      badge(false, '연결 실패');
      console.warn('시장 목록 조회 실패(계속 진행):', e?.message);
    }
    wireTable();
    mountAutoToggle();
  });
})();
</script>
<!-- ====== /ONE-SHOT PATCH ====== -->
