<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>쩔어지갑 v7.0 안정판</title>
<style>
  :root{
    --bg:#0f141a;--panel:#121821;--muted:#9fb0c3;--text:#d7e2f2;--green:#2bd093;--red:#ff5a6f;--orange:#ffb74d;--line:#1c2733;--badge:#1a2330;--chip:#0f1722
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 Pretendard,system-ui,Segoe UI,Apple SD Gothic Neo,Malgun Gothic,sans-serif}
  .wrap{max-width:1180px;margin:28px auto;padding:0 16px}
  .title{display:flex;align-items:center;gap:10px;margin-bottom:12px}
  .badge{background:var(--badge);color:#bcd0e6;border:1px solid var(--line);padding:3px 8px;border-radius:8px;font-size:12px}
  .bar{display:flex;gap:8px;margin-bottom:10px}
  .bar .grow{flex:1}
  .ipt{width:100%;background:#0c1219;border:1px solid var(--line);color:var(--text);padding:12px 12px;border-radius:10px;outline:none}
  .btn{background:#0c1219;border:1px solid var(--line);color:var(--text);padding:10px 14px;border-radius:10px;cursor:pointer}
  .btn:hover{border-color:#2a3a4d}
  .row{display:flex;gap:12px;flex-direction:column}
  .panel{flex:1;background:var(--panel);border:1px solid var(--line);border-radius:14px;overflow:hidden}
  .panel h3{margin:0;padding:12px 14px;border-bottom:1px solid var(--line);background:#0f1722;font-size:14px;color:#bcd0e6;display:flex;align-items:center;justify-content:space-between}
  .summary{display:grid;grid-template-columns:repeat(8,1fr);gap:8px;padding:10px 12px;border-bottom:1px solid var(--line)}
  .summary .cell{background:var(--chip);border:1px solid var(--line);border-radius:10px;padding:10px 12px}
  .summary .ttl{color:#9fb0c3;font-size:12px;margin-bottom:6px}
  .summary .val{font-weight:700}
  .green{color:var(--green)} .red{color:var(--red)} .muted{color:var(--muted)}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px 12px;border-bottom:1px solid var(--line);text-align:right;white-space:nowrap}
  th{background:#0f1722;color:#9fb0c3;font-weight:600}
  td:first-child,th:first-child{text-align:center}
  td:nth-child(2),th:nth-child(2){text-align:left}
  .chip{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--line);background:var(--chip);color:#cfe2ff;font-size:12px}
  .note{display:flex;align-items:center;gap:6px}
  .tag{padding:2px 8px;border-radius:8px;border:1px solid var(--line);background:#0f1722;color:#cfe2ff;font-size:12px}
  .footer{margin-top:12px;color:#8597ab}
  .right{display:flex;gap:6px;align-items:center}
  .inline{display:inline-flex;gap:8px;align-items:center}
  @media(max-width:1100px){.summary{grid-template-columns:repeat(4,1fr)}}
  @media(max-width:720px){.row{flex-direction:column}}
</style>
</head>
<body>
  <div class="wrap">
    <div class="title">
      <div class="badge">쩔어지갑 v7.0 안정판</div>
      <div class="badge">ONLINE</div>
      <div class="badge" id="clock">KST — --:--:--</div>
      <div class="badge">업비트 프록시 고정</div>
    </div>

    <!-- 검색 바 (기존 위치 유지) -->
    <div class="bar">
      <input id="q" class="ipt grow" placeholder="코인 검색 (예: 이더리움 / ETH / KRW-ETH)" />
      <button class="btn" id="btnSearch">검색</button>
      <button class="btn" id="btnReset">초기화</button>
    </div>

    <!-- 선택된 코인 1줄 요약 (현재가/변동률/매수/매도/손절/위험도/쩔어한마디/변동률) -->
    <div class="panel">
      <div class="summary" id="selectedSummary">
        <!-- JS가 채움 -->
      </div>
    </div>

    <div style="height:10px"></div>

    <div class="row">
      <!-- 급등코인 -->
      <div class="panel">
        <h3>
          <span>🔥 급등코인 Top 10 <span class="muted">(조건: 실시간 변동률 기준)</span></span>
          <div class="right">
            <button class="btn" id="btnRiseRefresh">새로고침</button>
          </div>
        </h3>
        <div id="riseTableWrap">
          <table id="riseTable">
            <thead>
              <tr>
                <th>#</th>
                <th>코인명(한글)</th>
                <th>현재가</th>
                <th>변동률</th>
                <th>매수</th>
                <th>매도</th>
                <th>손절</th>
                <th>위험도</th>
                <th>쩔어한마디</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <!-- 급락코인 -->
      <div class="panel">
        <h3>
          <span>💧 급락코인 Top 10</span>
          <div class="right">
            <button class="btn" id="btnFallRefresh">새로고침</button>
          </div>
        </h3>
        <div id="fallTableWrap">
          <table id="fallTable">
            <thead>
              <tr>
                <th>#</th>
                <th>코인명(한글)</th>
                <th>현재가</th>
                <th>변동률</th>
                <th>매수</th>
                <th>매도</th>
                <th>손절</th>
                <th>위험도</th>
                <th>쩔어한마디</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="footer">
      ⓘ 실시간 자동 정렬 · 429 백오프 처리 · 호가단위 매핑 고정 · 검색(한글/영문/심볼/마켓코드)  
    </div>
  </div>

<script>
/* =========================
   유틸 & 상수
========================= */
const API = (path) => `/api/upbit?path=${encodeURIComponent(path)}`;

// KRW 호가 단위 (업비트와 동일 규칙)
function priceUnit(p){
  if (p >= 2_000_000) return 1_000;
  if (p >= 1_000_000) return 500;
  if (p >= 500_000)  return 100;
  if (p >= 100_000)  return 50;
  if (p >= 10_000)   return 10;
  if (p >= 1_000)    return 5;
  if (p >= 100)      return 1;
  if (p >= 10)       return 0.1;
  if (p >= 1)        return 0.01;
  if (p >= 0.1)      return 0.001;
  if (p >= 0.01)     return 0.0001;
  if (p >= 0.001)    return 0.00001;
  return 0.000001;
}
function roundToHoga(p){
  const u = priceUnit(p);
  return Math.round(p/u)*u;
}
const fmtKRW = (x) => {
  if (x==null || Number.isNaN(x)) return '-';
  const unit = priceUnit(Math.abs(x));
  return x.toLocaleString('ko-KR', {
    minimumFractionDigits: (unit<1)? String(unit).split('.')[1].length : 0,
    maximumFractionDigits: (unit<1)? String(unit).split('.')[1].length : 0
  });
};
const pct = (x) => (x>0?`<span class="green">${(x*100).toFixed(2)}%</span>`:
                          `<span class="red">${(x*100).toFixed(2)}%</span>`);

function clockTick(){
  const c = document.getElementById('clock');
  const now = new Date();
  c.textContent = 'KST — ' + now.toLocaleTimeString('ko-KR',{hour12:false});
}
setInterval(clockTick, 1000); clockTick();

/* =========================
   마켓/검색 인덱스 로드
========================= */
let MARKETS = [];                 // KRW-XXX Markets
let NAME_TO_MARKET = new Map();   // 한글/영문/심볼/마켓코드 -> market

async function loadMarkets(){
  const r = await fetch(API('/v1/market/all?isDetails=true'));
  if (!r.ok){ throw new Error('시장 목록 로드 실패 '+r.status); }
  const all = await r.json();
  MARKETS = all.filter(m => m.market.startsWith('KRW-'));
  NAME_TO_MARKET.clear();
  for (const m of MARKETS){
    NAME_TO_MARKET.set(m.korean_name, m.market);
    NAME_TO_MARKET.set(m.english_name?.toUpperCase?.(), m.market);
    const sym = m.market.replace('KRW-',''); // 심볼
    NAME_TO_MARKET.set(sym, m.market);
    NAME_TO_MARKET.set(m.market, m.market);
  }
}
function resolveMarket(query){
  if(!query) return null;
  const q = String(query).trim();
  // 완전일치 우선
  if (NAME_TO_MARKET.has(q)) return NAME_TO_MARKET.get(q);
  if (NAME_TO_MARKET.has(q.toUpperCase())) return NAME_TO_MARKET.get(q.toUpperCase());
  // 부분 포함(한글)
  for (const [k,v] of NAME_TO_MARKET){
    if (!k) continue;
    if (k.includes && k.includes(q)) return v;
  }
  return null;
}

/* =========================
   실시간 데이터 로드 (티커/호가)
========================= */
async function fetchTickers(mkts){
  if (!mkts.length) return [];
  // 200개 제한 우회: 100개 단위 fetch 후 합치기
  const batch = 100;
  const out = [];
  for (let i=0;i<mkts.length;i+=batch){
    const part = mkts.slice(i, i+batch).join(',');
    const url = API(`/v1/ticker?markets=${encodeURIComponent(part)}`);
    const r = await fetch(url);
    if (!r.ok) throw new Error('ticker fail '+r.status);
    out.push(...await r.json());
  }
  return out;
}
async function fetchOrderbook(mkts){
  if (!mkts.length) return [];
  const batch = 50;
  const out = [];
  for (let i=0;i<mkts.length;i+=batch){
    const part = mkts.slice(i, i+batch).join(',');
    const url = API(`/v1/orderbook?markets=${encodeURIComponent(part)}`);
    const r = await fetch(url);
    if (!r.ok) throw new Error('orderbook fail '+r.status);
    out.push(...await r.json());
  }
  return out;
}

/* =========================
   위험도/쩔어한마디/타점 계산
========================= */
// 아주 단순한 실시간 힌트 로직: 변동률 + 호가불균형 기반
function analyzeRow(ticker, obMap){
  const change = ticker.signed_change_rate;  // -1~+1
  const price  = ticker.trade_price;
  const ob     = obMap.get(ticker.market);
  let bestBid=null,bestAsk=null,bidSum=0,askSum=0;
  if (ob){
    bestBid = ob.orderbook_units[0]?.bid_price;
    bestAsk = ob.orderbook_units[0]?.ask_price;
    for (const u of ob.orderbook_units.slice(0,10)){
      bidSum += u.bid_size;
      askSum += u.ask_size;
    }
  }
  const imbalance = bidSum/(askSum||1); // >1.0 이면 매수 우위
  // 손절/매수/매도 타점(호가단위 반올림)
  const buy  = roundToHoga(price * (change>0 ? 0.996 : 0.992));
  const sell = roundToHoga(price * (change>0 ? 1.004 : 1.006));
  const stop = roundToHoga(price * (change>0 ? 0.985 : 0.975));

  let risk='1(안정)'; // 1~3
  if (Math.abs(change)>0.05 || imbalance>1.6 || imbalance<0.65) risk='3(주의)';
  else if (Math.abs(change)>0.02 || imbalance>1.25 || imbalance<0.8) risk='2(보통)';

  let comment='관망';
  if (change>0.04 && imbalance>1.3) comment='🚀 폭등 모드!';
  else if (change>0.02 && imbalance>1.2) comment='🔥 불장 신호!';
  else if (change<-0.04 && imbalance<0.8) comment='📉 낙폭경계';

  return {
    buy, sell, stop, risk, comment,
    bestBid, bestAsk, imbalance
  };
}

/* =========================
   렌더러
========================= */
function fillSelectedSummary(row){
  // 8셀: 코인명/현재가/변동률/매수/매도/손절/위험도/쩔어한마디
  const el = document.getElementById('selectedSummary');
  if (!row){
    el.innerHTML = Array.from({length:8}).map(()=>`
      <div class="cell"><div class="ttl">-</div><div class="val muted">--</div></div>`).join('');
    return;
  }
  el.innerHTML = `
    <div class="cell"><div class="ttl">선택된 코인</div><div class="val">${row.korean_name} <span class="muted">(${row.market})</span></div></div>
    <div class="cell"><div class="ttl">현재가</div><div class="val">${fmtKRW(row.trade_price)}</div></div>
    <div class="cell"><div class="ttl">변동률</div><div class="val">${pct(row.signed_change_rate)}</div></div>
    <div class="cell"><div class="ttl">매수</div><div class="val">${fmtKRW(row.buy)}</div></div>
    <div class="cell"><div class="ttl">매도</div><div class="val">${fmtKRW(row.sell)}</div></div>
    <div class="cell"><div class="ttl">손절</div><div class="val">${fmtKRW(row.stop)}</div></div>
    <div class="cell"><div class="ttl">위험도</div><div class="val">${row.risk}</div></div>
    <div class="cell"><div class="ttl">쩔어한마디</div><div class="val">${row.comment}</div></div>
  `;
}
function renderTable(tbody, rows){
  tbody.innerHTML = rows.map((r,i)=>`
    <tr>
      <td>${i+1}</td>
      <td>${r.korean_name} <span class="muted">(${r.market})</span></td>
      <td>${fmtKRW(r.trade_price)}</td>
      <td>${pct(r.signed_change_rate)}</td>
      <td>${fmtKRW(r.buy)}</td>
      <td>${fmtKRW(r.sell)}</td>
      <td>${fmtKRW(r.stop)}</td>
      <td>${r.risk}</td>
      <td class="note"><span class="tag">${r.comment}</span></td>
    </tr>
  `).join('');
}

/* =========================
   메인 로직
========================= */
let LAST_MARKET = null;

async function refreshAll(selectMarket=null){
  try{
    await loadMarkets();

    const mkts = MARKETS.map(m=>m.market);
    const [ticks, books] = await Promise.all([
      fetchTickers(mkts),
      fetchOrderbook(mkts)
    ]);
    const obMap = new Map(books.map(b=>[b.market,b]));
    const info = new Map(MARKETS.map(m=>[m.market,m]));

    // 분석 결과 합성
    const rows = ticks.map(t=>{
      const z = analyzeRow(t, obMap);
      const meta = info.get(t.market) || {};
      return {
        ...t,
        korean_name: meta.korean_name || t.market,
        ...z
      };
    });

    // 정렬
    const rising = [...rows].sort((a,b)=> b.signed_change_rate - a.signed_change_rate).slice(0,10);
    const falling= [...rows].sort((a,b)=> a.signed_change_rate - b.signed_change_rate).slice(0,10);

    renderTable(document.querySelector('#riseTable tbody'), rising);
    renderTable(document.querySelector('#fallTable tbody'), falling);

    // 선택코인 처리
    let selectedRow = null;
    const m = selectMarket || LAST_MARKET;
    if (m){
      selectedRow = rows.find(r=>r.market===m) || null;
    }
    fillSelectedSummary(selectedRow);
  }catch(e){
    console.error(e);
    alert('데이터 갱신 중 오류: '+e.message);
  }
}

function doSearch(){
  const q = document.getElementById('q').value.trim();
  if (!q){ LAST_MARKET = null; fillSelectedSummary(null); return; }
  const m = resolveMarket(q);
  if (!m){
    alert('코인을 찾지 못했습니다. (한글/영문/심볼/마켓코드 지원)');
    return;
  }
  LAST_MARKET = m;
  // 선택코인만 부분 새로고침
  refreshAll(m);
}

/* =========================
   이벤트
========================= */
document.getElementById('btnSearch').onclick = doSearch;
document.getElementById('btnReset').onclick  = ()=>{ document.getElementById('q').value=''; LAST_MARKET=null; fillSelectedSummary(null); };
document.getElementById('btnRiseRefresh').onclick = ()=>refreshAll(LAST_MARKET);
document.getElementById('btnFallRefresh').onclick = ()=>refreshAll(LAST_MARKET);
// 엔터 검색
document.getElementById('q').addEventListener('keydown',e=>{
  if (e.key==='Enter') doSearch();
});

/* 초기 구동 */
refreshAll();
<script>
/* ====== 빠른 검색 가속기 (기존 기능 유지) ====== */
(() => {
  const API = '/api/upbit?path=/v1/market/all?isDetails=true';
  const $q = document.querySelector('#q, [data-id="q"]') || document.querySelector('input[type="search"]');
  const $btn = document.querySelector('#btnSearch, [data-id="btn-search"]') || document.querySelector('button.search');
  if (!$q) return; // 검색창이 없으면 아무 것도 안 함

  // (선택) 입력창에 자동완성 표시용 datalist 연결
  let $list = document.querySelector('#coins_datalist');
  if (!$list) {
    $list = document.createElement('datalist');
    $list.id = 'coins_datalist';
    document.body.appendChild($list);
  }
  $q.setAttribute('list', 'coins_datalist');

  // 상태
  const state = {
    idx: [],                 // {market, ko, en, sym, key}
    map: new Map(),          // market -> full row
    ready: false,
    buildCtrl: null,
    lastCtrl: null,          // 마지막 네트워크 요청 취소용(필요 시)
    cache: new Map(),        // 여유: 검색어 -> 배열 캐시
  };

  // 유틸
  const norm = s => String(s || '')
    .toLowerCase()
    .replace(/\s+/g, '')
    .replace(/[^\w\-가-힣]/g, '');

  const debounce = (fn, ms=200) => {
    let t; return (...a) => { clearTimeout(t); t=setTimeout(()=>fn(...a), ms); };
  };

  // 인덱스 구축(앱 최초 1회)
  async function buildIndex() {
    try {
      state.buildCtrl?.abort();
      state.buildCtrl = new AbortController();
      const r = await fetch(API, { signal: state.buildCtrl.signal, cache: 'no-store' });
      if (!r.ok) throw new Error('market/all fetch fail: ' + r.status);
      const arr = await r.json();
      state.idx.length = 0;
      state.map.clear();
      for (const it of arr) {
        const market = it.market;           // e.g. KRW-BTC
        const [symBase, sym] = market.split('-'); // KRW, BTC
        const row = {
          market,
          ko: it.korean_name || '',
          en: it.english_name || '',
          sym: sym || '',
          base: symBase || '',
        };
        state.map.set(market, row);
        state.idx.push({
          market,
          ko: norm(row.ko),
          en: norm(row.en),
          sym: norm(row.sym),
          key: norm(row.ko + row.en + row.sym + market)
        });
      }
      state.ready = true;
      // 초기에 인기 마켓 일부 자동완성
      renderDatalist(suggest('krw'));
    } catch (e) {
      console.warn('[search] buildIndex error', e);
    }
  }

  function suggest(q) {
    q = norm(q);
    if (!q) return [];
    if (state.cache.has(q)) return state.cache.get(q);

    // 우선순위: 정확 매치 > 부분 매치(심볼/한글/영문)
    // 너무 많으면 상위 15개만
    const hits = [];
    for (const r of state.idx) {
      let score = 0;
      if (r.sym === q) score += 10;
      if (r.ko === q || r.en === q) score += 9;
      if (r.key.includes(q)) score += 5;
      if (r.sym.startsWith(q)) score += 4;
      if (r.ko.startsWith(q) || r.en.startsWith(q)) score += 3;
      if (score > 0) hits.push({ m: r.market, score });
    }
    hits.sort((a,b)=>b.score - a.score);
    const top = hits.slice(0, 15).map(h => state.map.get(h.m));
    state.cache.set(q, top);
    return top;
  }

  function renderDatalist(list) {
    if (!$list) return;
    const frag = document.createDocumentFragment();
    for (const it of list) {
      const opt = document.createElement('option');
      opt.value = `${it.ko} (${it.market})`;
      frag.appendChild(opt);
    }
    $list.innerHTML = '';
    $list.appendChild(frag);
  }

  // 빠른 제안(타이핑 중)
  const onInput = debounce(() => {
    if (!state.ready) return;
    const q = $q.value.trim();
    if (!q) { $list.innerHTML = ''; return; }
    renderDatalist(suggest(q));
  }, 200);

  // 기존 “검색 버튼/엔터” 로직 존중: 최상단 후보의 market만 찾아서
  // 기존 함수로 넘겨줍니다. (아래 두 함수 이름 중 프로젝트에 있는 걸 쓰세요)
  function fireSelect(market) {
    // 1) 기존에 사용하던 함수가 있으면 그대로 호출
    if (typeof selectCoin === 'function') return selectCoin(market);
    if (typeof loadCoin === 'function')   return loadCoin(market);

    // 2) 없으면 input에 market만 남기고(UX) 기존 핸들러가 읽도록 둠
    $q.value = market;
    // 기존 버튼 클릭 핸들러 트리거(있으면)
    $btn?.click();
  }

  function confirmSearch() {
    const qraw = $q.value.trim();
    if (!qraw) return;
    // 사용자가 "코인이름 (KRW-XXX)" 형식에서 market만 뽑았을 수도 있음
    const m = qraw.match(/\((\w+-\w+)\)\s*$/);
    if (m) return fireSelect(m[1]);

    // 그 외엔 상담 후보 1순위로
    const cands = suggest(qraw);
    if (cands.length) return fireSelect(cands[0].market);
  }

  // 이벤트 설치
  $q.addEventListener('input', onInput);
  $q.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') confirmSearch();
  });
  $btn?.addEventListener('click', (e)=>{
    e.preventDefault();
    confirmSearch();
  });

  // 시작 시 인덱스 준비
  buildIndex();
})();
</script>

</script>
</body>
</html>


