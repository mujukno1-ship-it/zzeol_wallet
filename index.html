<script>
// ===== 급등 피드 (항상 '최신 감지'가 맨 위) =====
const FEED_KEY = 'zzeol_hot_feed_v1';
const FEED_TTL_HOURS = 24;
const rowBySym = new Map(); // 심볼 -> <tr> 매핑
let storeCache = [];        // 저장소 캐시 (최신이 앞)

function loadFeedFromStore() {
  try {
    const raw = localStorage.getItem(FEED_KEY);
    if (!raw) return [];
    const arr = JSON.parse(raw);
    const now = Date.now();
    return arr.filter(x => now - x.ts < FEED_TTL_HOURS * 3600 * 1000).slice(0, 100);
  } catch { return []; }
}
function saveFeedToStore(items) {
  try { localStorage.setItem(FEED_KEY, JSON.stringify(items.slice(0, 100))); }
  catch (e) { console.warn('feed save failed', e); }
}
function renderFeed(items) {
  const feed = document.getElementById('hotFeed');
  feed.innerHTML = '';
  rowBySym.clear();
  for (const it of items) {
    const tr = document.createElement('tr');
    tr.style.textAlign = 'center';
    tr.innerHTML = `
      <td>💥 ${it.nameKo || it.sym}</td>
      <td>${it.price}</td>
      <td>${it.buy}</td>
      <td>${it.sell}</td>
      <td>${it.stop}</td>
      <td>${it.risk}</td>
      <td>${it.comment}</td>`;
    feed.appendChild(tr);
    rowBySym.set(it.sym, tr);
  }
  storeCache = items;
}
document.getElementById('btnFeedClear')?.addEventListener('click', () => {
  localStorage.removeItem(FEED_KEY);
  renderFeed([]);
  alert('급등 피드를 비웠습니다.');
});

// 유틸: 배열 맨 앞에 최신으로 넣되 중복 제거
function upsertFront(entry) {
  storeCache = [entry, ...storeCache.filter(x => x.sym !== entry.sym)];
  saveFeedToStore(storeCache);
}

// 업비트 요청 보조
function chunk(arr, size){ const out=[]; for(let i=0;i<arr.length;i+=size) out.push(arr.slice(i,i+size)); return out; }
async function fetchJSON(url, {timeout=8000, retries=2, backoff=500}={}) {
  for (let a=0; a<=retries; a++) {
    const ctrl = new AbortController(); const timer = setTimeout(()=>ctrl.abort(), timeout);
    try {
      const res = await fetch(url, {signal: ctrl.signal, cache: 'no-store'});
      if (!res.ok) throw new Error('HTTP '+res.status);
      return await res.json();
    } catch (e) {
      if (a === retries) throw e;
      await new Promise(r => setTimeout(r, backoff * Math.pow(2,a)));
    } finally { clearTimeout(timer); }
  }
}
async function getTickersBatch(markets){
  const parts = chunk(markets, 60);
  const out = [];
  for (const p of parts) {
    const r = await fetchJSON('https://api.upbit.com/v1/ticker?markets='+p.join(',')); 
    out.push(...r);
  }
  return out;
}

// 핵심: 새로 감지되면 (이미 표에 있어도) 값 업데이트 + 맨 위로 이동
async function loadHotOnce() {
  const list = await ensureMarkets();      // <- 너의 기존 함수 유지됨
  const tickers = await getTickersBatch(list.map(x => x.market));
  const hot = tickers
    .filter(t => t.signed_change_rate > 0.05 && t.acc_trade_price_24h > 10_000_000_000)
    .sort((a,b)=> b.signed_change_rate - a.signed_change_rate);

  const feed = document.getElementById('hotFeed');

  for (const t of hot) {
    const market = t.market;
    const sym = market.replace('KRW-','');
    const nameKo = (typeof NAME_KO !== 'undefined' && NAME_KO.get) ? (NAME_KO.get(market) || sym) : sym;

    const p = t.trade_price, rate = t.signed_change_rate;
    const entry = {
      ts: Date.now(),
      sym,
      nameKo,
      price: fmtKRW(p),
      buy:   fmtKRW(p*0.988),
      sell:  fmtKRW(p*1.012),
      stop:  fmtKRW(p*0.975),
      risk:  (typeof riskText==='function'? riskText(rate): '—'),
      comment: (typeof zzeolComment==='function'? zzeolComment(rate): '—')
    };

    if (rowBySym.has(sym)) {
      // 이미 표에 있던 코인: 내용 업데이트 후 맨 위로 이동
      const tr = rowBySym.get(sym);
      tr.innerHTML = `
        <td>💥 ${entry.nameKo}</td>
        <td>${entry.price}</td>
        <td>${entry.buy}</td>
        <td>${entry.sell}</td>
        <td>${entry.stop}</td>
        <td>${entry.risk}</td>
        <td>${entry.comment}</td>`;
      tr.classList.add('flash');
      feed.prepend(tr);            // ✅ 항상 위로
      setTimeout(()=>tr.classList.remove('flash'), 900);
      upsertFront(entry);          // 저장소에서도 최신으로 갱신
    } else {
      // 새 코인: 새 행 만들고 맨 위로
      const tr = document.createElement('tr');
      tr.style.textAlign='center'; tr.classList.add('flash');
      tr.innerHTML = `
        <td>💥 ${entry.nameKo}</td>
        <td>${entry.price}</td>
        <td>${entry.buy}</td>
        <td>${entry.sell}</td>
        <td>${entry.stop}</td>
        <td>${entry.risk}</td>
        <td>${entry.comment}</td>`;
      feed.prepend(tr);
      setTimeout(()=>tr.classList.remove('flash'), 900);
      rowBySym.set(sym, tr);
      upsertFront(entry);
    }
  }
}

// 부팅: 저장본 먼저 복원 → 주기적으로 스캔(30초)
window.addEventListener('DOMContentLoaded', async ()=>{
  // 한글명 맵을 쓰는 버전이면 ensureMarkets 먼저
  try { if (typeof ensureMarkets==='function') await ensureMarkets(); } catch {}
  const boot = loadFeedFromStore();
  if (boot.length) renderFeed(boot);
  await loadHotOnce();
  setInterval(loadHotOnce, 30000); // 30초마다 감지
});
</script>
