<script>
/* zzeol-wallet Hotfix v2.3
   - WS 차단 시 자동 폴백(REST)
   - REST도 CORS/429 시 프록시 + 지수백오프
   - 무효 마켓코드 필터, 하트비트(KRW-BTC)
   - 기존 UI/표/전략(calcTradeLevels) 그대로 사용
*/
(function(){
  /* ───────── 공통 유틸 ───────── */
  const isMarket = (m)=> /^KRW-[A-Z0-9]{2,}$/.test(m||'');
  const asKRW = (x)=> (typeof fmtKRW==='function' ? fmtKRW(x) : Math.round(x).toLocaleString('ko-KR'));
  function mark(status){ const n=document.getElementById('net'); if(!n) return;
    if(status==='ONLINE'){ n.textContent='ONLINE'; n.style.background='#123922'; }
    else { n.textContent='OFFLINE (재시도)'; n.style.background='#3a1a1a'; } }

  // 화면에서 구독할 마켓 모으기 (검색코인 + 급등/급락 표)
  function collectMarkets(){
    const set = new Set();
    const sel = document.getElementById('selMarket');
    if (sel){ const m=(sel.textContent||'').trim(); if(isMarket(m)) set.add(m); }
    document.querySelectorAll('#feedUp tr[data-market],#feedDown tr[data-market]').forEach(tr=>{
      const m=tr.getAttribute('data-market'); if(isMarket(m)) set.add(m);
    });
    const list = Array.from(set);
    return list.length ? list.slice(0,80) : ['KRW-BTC']; // 하트비트
  }

  // 표/카드 즉시 반영
  function applyTicker(t){
    const market=t.code||t.market, price=t.trade_price, rate=(t.signed_change_rate??0);
    // 검색 카드
    const sel=document.getElementById('selMarket');
    if (sel && (sel.textContent||'').trim()===market){
      const priceEl=document.getElementById('s_price');
      const rateEl =document.getElementById('s_rate');
      const calc=(window.calcTradeLevels||(p=>({buy:p*0.988,sell:p*1.012,stop:p*0.975})));
      const L=calc(price,rate);
      if(priceEl) priceEl.textContent=asKRW(price);
      if(rateEl)  rateEl.innerHTML=`<span class="chg ${rate>=0?'up':'down'}">${(rate*100).toFixed(2)}%</span>`;
      ['s_buy','s_sell','s_stop'].forEach((id,i)=>{
        const v=[L.buy,L.sell,L.stop][i]; const el=document.getElementById(id);
        if(el) el.textContent=asKRW(v);
      });
    }
    // 급등/급락 표
    document.querySelectorAll(`tr[data-market="${market}"]`).forEach(tr=>{
      const tds=tr.querySelectorAll('td'); if(tds.length<9) return;
      const calc=(window.calcTradeLevels||(p=>({buy:p*0.988,sell:p*1.012,stop:p*0.975})));
      const L=calc(price,rate);
      tds[2].textContent=asKRW(price);
      tds[3].innerHTML =`<span class="chg ${rate>=0?'up':'down'}">${(rate*100).toFixed(2)}%</span>`;
      tds[4].textContent=asKRW(L.buy);
      tds[5].textContent=asKRW(L.sell);
      tds[6].textContent=asKRW(L.stop);
    });
  }

  /* ───────── CORS/429 대응 fetch ───────── */
  async function fetchJSONWithFallback(url, timeout=9000){
    const PROXIES=['https://corsproxy.io/?','https://api.allorigins.win/raw?url='];
    // 1) 직접 시도
    try{
      const ctrl=new AbortController(); const tm=setTimeout(()=>ctrl.abort(),timeout);
      const r=await fetch(url,{signal:ctrl.signal,cache:'no-store'}); clearTimeout(tm);
      if(!r.ok) throw Object.assign(new Error('HTTP '+r.status),{status:r.status});
      return await r.json();
    }catch(e){}
    // 2) 프록시 순차 시도
    for (let i=0;i<PROXIES.length;i++){
      try{
        const ctrl=new AbortController(); const tm=setTimeout(()=>ctrl.abort(),timeout);
        const r=await fetch(PROXIES[i]+url,{signal:ctrl.signal,cache:'no-store'}); clearTimeout(tm);
        if(!r.ok) throw Object.assign(new Error('HTTP '+r.status),{status:r.status});
        return await r.json();
      }catch(e){ if(i===PROXIES.length-1) throw e; }
    }
  }
  async function getTickersSafe(markets){
    const url='https://api.upbit.com/v1/ticker?markets='+markets.join(',');
    return await fetchJSONWithFallback(url, 9000);
  }

  /* ───────── WS + 폴링(지수 백오프) ───────── */
  const WS_URL='wss://api.upbit.com/websocket/v1';
  let ws=null, wsAlive=false, reconnectTimer=null;
  let pollTimer=null, pollDelay=1200; // 시작 1.2s, 429면 늘림
  const FORCE_POLL=/[?&]poll=1\b/.test(location.search);

  function stopPolling(){ if(pollTimer){ clearTimeout(pollTimer); pollTimer=null; console.log('[POLL] stop'); } }
  async function pollLoop(){
    const mkts=collectMarkets();
    try{
      const arr=await getTickersSafe(mkts);
      if(Array.isArray(arr)){ arr.forEach(applyTicker); mark('ONLINE'); pollDelay=1200; }
    }catch(e){
      const status=e?.status||0;
      // 429면 텀을 키워주고, 그 외는 기본 2초
      pollDelay = status===429 ? Math.min(Math.round(pollDelay*1.5), 5000) : 2000;
      console.warn('[POLL] error, delay ->', pollDelay, e);
      mark('OFFLINE (재시도)');
    }
    pollTimer=setTimeout(pollLoop, pollDelay);
  }
  function startPolling(){ if(pollTimer) return; console.log('[POLL] start'); pollDelay=1200; pollLoop(); }

  function scheduleReconnect(){
    if(reconnectTimer) return;
    startPolling(); mark('OFFLINE (재시도)');
    let d=1500;
    reconnectTimer=setTimeout(()=>{ reconnectTimer=null; connectWS(); }, d);
  }

  function connectWS(){
    if(FORCE_POLL){ console.log('[WS] force poll mode'); startPolling(); return; }
    const codes=collectMarkets();
    console.log('[WS] subscribe', codes);
    try{
      stopPolling();
      if(ws){ try{ws.close();}catch(_){ } ws=null; }
      ws=new WebSocket(WS_URL);
      ws.binaryType='blob';

      ws.onopen=()=>{
        wsAlive=true; mark('ONLINE');
        const msg=[{ticket:'zzeol-wallet'},{type:'ticker',codes,isOnlyRealtime:true}];
        ws.send(JSON.stringify(msg));
        console.log('[WS] opened');
      };
      ws.onmessage=async (e)=>{
        try{ const text=await e.data.text(); const data=JSON.parse(text); applyTicker(data); }
        catch(_){}
      };
      ws.onclose =()=>{ wsAlive=false; console.warn('[WS] closed'); scheduleReconnect(); };
      ws.onerror =()=>{ wsAlive=false; console.warn('[WS] error');  scheduleReconnect(); };
    }catch(e){
      console.warn('[WS] connect fail', e); scheduleReconnect();
    }
  }

  // 네트워크/탭 상태에 따라 자동 전환
  window.addEventListener('online', ()=>{ try{ if(ws) ws.close(); }catch(_){ } connectWS(); });
  window.addEventListener('offline',()=>{ startPolling(); mark('OFFLINE (재시도)'); });
  document.addEventListener('visibilitychange', ()=>{ if(!document.hidden){ try{ if(ws) ws.close(); }catch(_){ } connectWS(); }});

  // 부팅
  connectWS();
  // 1분마다 재구독(리스트가 바뀌어도 반영)
  setInterval(()=>{ if(wsAlive){ try{ws.close();}catch(_){ } } connectWS(); }, 60*1000);
})();
</script>
