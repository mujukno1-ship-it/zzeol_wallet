<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>쩔어지갑 v6.3</title>
<style>
  :root{
    --bg:#0f141a;--card:#141b23;--text:#e6edf3;--muted:#97a3af;--green:#14cc8a;--red:#ff5c62;--amber:#fbbf24;--blue:#60a5fa;
    --chip:#1f2937;--chip-b:#263241;--accent:#2b3340;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 system-ui,Segoe UI,Apple SD Gothic Neo,Malgun Gothic,sans-serif}
  .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
  .row{display:flex;gap:8px;align-items:center}
  .topbar{display:flex;gap:8px;align-items:center;margin-bottom:12px}
  .badge{font-size:12px;color:#b6c2cf;background:#1c2330;border:1px solid #273142;padding:2px 8px;border-radius:999px}
  .pill{padding:6px 10px;background:#1a2330;border:1px solid #2a3547;border-radius:10px;color:var(--text)}
  .pill input{all:unset;color:inherit}
  .btn{border:1px solid #2c394c;background:#17202b;color:var(--text);padding:6px 10px;border-radius:8px;cursor:pointer}
  .btn:hover{background:#1d2836}
  .box{background:var(--card);border:1px solid #253246;border-radius:12px;padding:12px;margin-top:10px}
  .box-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
  .box-title{font-weight:700}
  .grid{display:grid;grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1.1fr;gap:6px;padding:10px;border-top:1px dashed #283246}
  .grid.head{color:#9fb0c3;background:#16202a;border-top:none;border-radius:8px}
  .grid .c{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;background:var(--chip);border:1px solid var(--chip-b);font-size:12px;color:#b9c6d6}
  .muted{color:var(--muted)}
  .green{color:var(--green)} .red{color:var(--red)} .amber{color:var(--amber)}
  .hint{font-size:12px;color:#8aa0b2}
  .right{display:flex;gap:6px;align-items:center}
  .sticky{position:sticky;top:0;z-index:10;background:var(--bg);padding-top:6px}
  a.link{color:#84c5ff;text-decoration:none}
  .w120{min-width:120px}
  .center{text-align:center}
</style>
</head>
<body>
<div class="wrap">

  <!-- 상단 바 -->
  <div class="topbar">
    <span class="badge">v6.3</span>
    <span class="badge" id="net">ONLINE</span>
    <span class="badge" id="clock">KST —</span>
  </div>

  <!-- 검색 / 컨트롤 -->
  <div class="row sticky">
    <div class="pill" style="flex:1">
      <input id="q" placeholder="코인 검색 (예: 비트코인 / 비트코인캐시 / 이더리움 / 이더리움클래식 / KRW-BTC …)" />
    </div>
    <button class="btn" id="btnSearch">검색</button>
    <button class="btn" id="btnReset">초기화</button>
  </div>

  <!-- 선택된 코인 상태 -->
  <div class="box" id="selectedBox">
    <div class="box-header">
      <div class="box-title">선택된 코인: <span id="selName" class="muted">없음</span></div>
      <div class="right">
        <label class="hint"><input type="checkbox" id="chkMomentum" /> 상승 탄력</label>
        <button class="btn" id="btnRefresh">새로고침</button>
      </div>
    </div>
    <div class="grid head">
      <div class="c">현재가</div><div class="c">매수</div><div class="c">매도</div>
      <div class="c">손절</div><div class="c">변동률</div><div class="c">위험도</div><div class="c">쩔어한마디</div>
    </div>
    <div class="grid" id="selectedGrid"><div class="c muted">—</div><div class="c muted">—</div><div class="c muted">—</div><div class="c muted">—</div><div class="c muted">—</div><div class="c muted">—</div><div class="c muted">—</div></div>
  </div>

  <!-- 급등코인 -->
  <div class="box">
    <div class="box-header">
      <div class="box-title">🔥 급등코인 Top 10</div>
      <div class="right hint">실시간 자동 정렬 (조건 표시는 제거됨)</div>
    </div>
    <div class="grid head">
      <div class="c">#</div><div class="c">코인명(한글)</div><div class="c">현재가</div>
      <div class="c">변동률</div><div class="c">매수</div><div class="c">매도</div>
      <div class="c">손절</div><div class="c">위험도</div><div class="c">쩔어한마디</div>
    </div>
    <div id="upList"></div>
  </div>

  <!-- 급락코인 -->
  <div class="box">
    <div class="box-header">
      <div class="box-title">💧 급락코인 Top 10</div>
      <div class="right hint">급등과 같은 포맷으로 표기</div>
    </div>
    <div class="grid head">
      <div class="c">#</div><div class="c">코인명(한글)</div><div class="c">현재가</div>
      <div class="c">변동률</div><div class="c">매수</div><div class="c">매도</div>
      <div class="c">손절</div><div class="c">위험도</div><div class="c">쩔어한마디</div>
    </div>
    <div id="downList"></div>
  </div>

</div>

<script>
/* ========= 유틸 ========= */
const $ = (s, p=document) => p.querySelector(s);
const $$ = (s, p=document) => [...p.querySelectorAll(s)];
const fmt = n => (n==null||isNaN(n)) ? '—' : n.toLocaleString('ko-KR');
const pct = v => (v>0?`<span class="green">${(v*100).toFixed(2)}%</span>`:
                  v<0?`<span class="red">${(v*100).toFixed(2)}%</span>`:`0.00%`);

const upbit = (p) =>
  fetch(`/api/upbit?path=${encodeURIComponent(p)}`, { cache:'no-store' })
  .then(r => { if (!r.ok) throw new Error(`Upbit ${r.status}`); return r.json(); });

const sleep = ms => new Promise(r=>setTimeout(r,ms));

/* ========= 시계/네트워크 ========= */
function tickClock(){
  const kst = new Date();
  $('#clock').textContent = `KST — ${kst.getHours()}시 ${kst.getMinutes()}분 ${kst.getSeconds()}초`;
}
setInterval(tickClock, 1000); tickClock();
window.addEventListener('online', ()=>$('#net').textContent='ONLINE');
window.addEventListener('offline', ()=>$('#net').textContent='OFFLINE');

/* ========= 전역 상태 ========= */
let MARKETS = [];        // [{market, korean_name, english_name}]
let KRW = [];            // KRW-* 만
let TICKERS = new Map(); // market -> ticker
let LAST_SELECTED = null;
let pollingTimer = null;

/* ========= 데이터 로드 ========= */
async function loadMarkets(){
  const arr = await upbit('/v1/market/all?isDetails=true');
  MARKETS = arr;
  KRW = arr.filter(m => m.market.startsWith('KRW-'));
}

async function loadTickers(markets){
  const SIZE = 90; // 업비트 URL 길이 제한 대비
  for (let i=0;i<markets.length;i+=SIZE){
    const slice = markets.slice(i,i+SIZE).map(m=>m.market||m);
    const tick = await upbit('/v1/ticker?markets='+slice.join(','));
    tick.forEach(t => TICKERS.set(t.market, t));
    await sleep(120);
  }
}

/* ========= 타점 계산 =========
   - 매수/매도: 현재가 ± 스프레드(가상 0.2%)
   - 손절: 전일종가 대비 -3% (또는 변동률 하락이면 더 타이트)
   - 위험도: (고가-저가)/현재가 (최근 24h 변동 폭 없으면 변동률 절대값 사용)
   - 쩔어한마디: 변동/모멘텀/위험도 기반 간단 멘션
*/
function calcPoints(t){
  const price = t.trade_price;
  const spread = Math.max(0.002*price, 1); // 0.2% 또는 최소 1원
  const bid = price - spread;
  const ask = price + spread;
  const change = t.signed_change_rate || 0;
  const stop = Math.max(1, Math.round(price * (change<0 ? 0.965 : 0.97))); // -3~3.5%
  const risk = Math.min(0.5, Math.abs(change) + (t.high_price&&t.low_price ? (t.high_price - t.low_price)/price : 0));
  let msg = '관망';
  if (change > 0.08 && risk < 0.12) msg = '🚀 폭등 모드!';
  else if (change > 0.03) msg = '🔥 불장 신호!';
  else if (change < -0.06) msg = '🧯 낙폭경계';
  else if (risk > 0.25) msg = '⚠️ 변동 주의';
  return {
    buy: Math.round(bid),
    sell: Math.round(ask),
    stop,
    risk,
    msg
  };
}

/* ========= 렌더 ========= */
function marketName(market){
  const m = MARKETS.find(x => x.market === market);
  return m ? m.korean_name : market;
}

function rowHTML(idx, t){
  const p = calcPoints(t);
  return `
  <div class="grid">
    <div class="c muted">${idx}</div>
    <div class="c"><a class="link" href="javascript:void(0)" data-market="${t.market}">${marketName(t.market)}</a></div>
    <div class="c">${fmt(t.trade_price)}</div>
    <div class="c">${pct(t.signed_change_rate)}</div>
    <div class="c">${fmt(p.buy)}</div>
    <div class="c">${fmt(p.sell)}</div>
    <div class="c">${fmt(p.stop)}</div>
    <div class="c">${(p.risk>0.25?'<span class="amber">높음</span>':p.risk>0.12?'<span class="muted">보통</span>':'<span class="green">낮음</span>')}</div>
    <div class="c">${p.msg}</div>
  </div>`;
}

function renderLists(){
  // 배열로 변환
  const arr = KRW.map(m => TICKERS.get(m.market)).filter(Boolean);

  // 급등/급락 정렬
  const ups = [...arr].sort((a,b)=> (b.signed_change_rate||0)-(a.signed_change_rate||0)).slice(0,10);
  const downs = [...arr].sort((a,b)=> (a.signed_change_rate||0)-(b.signed_change_rate||0)).slice(0,10);

  $('#upList').innerHTML = ups.map((t,i)=>rowHTML(i+1,t)).join('');
  $('#downList').innerHTML = downs.map((t,i)=>rowHTML(i+1,t)).join('');

  // 클릭 선택
  $$('#upList a.link, #downList a.link').forEach(a=>{
    a.onclick = ()=> selectMarket(a.dataset.market);
  });
}

function renderSelected(){
  const m = LAST_SELECTED;
  if (!m){ $('#selName').textContent = '없음'; return; }

  $('#selName').textContent = `${marketName(m)} (${m})`;
  const t = TICKERS.get(m);
  if (!t){
    $('#selectedGrid').innerHTML = '<div class="c muted">—</div>'.repeat(7);
    return;
  }
  const p = calcPoints(t);
  $('#selectedGrid').innerHTML = `
    <div class="c">${fmt(t.trade_price)}</div>
    <div class="c">${fmt(p.buy)}</div>
    <div class="c">${fmt(p.sell)}</div>
    <div class="c">${fmt(p.stop)}</div>
    <div class="c">${pct(t.signed_change_rate)}</div>
    <div class="c">${(p.risk>0.25?'<span class="amber">높음</span>':p.risk>0.12?'<span class="muted">보통</span>':'<span class="green">낮음</span>')}</div>
    <div class="c">${p.msg}</div>
  `;
}

/* ========= 선택/검색 ========= */
const saveState = () => localStorage.setItem('zzeol_state', JSON.stringify({
  last: LAST_SELECTED, mom: $('#chkMomentum').checked
}));
const loadState = () => {
  try{
    const s = JSON.parse(localStorage.getItem('zzeol_state')||'{}');
    LAST_SELECTED = s.last || null;
    $('#chkMomentum').checked = !!s.mom;
  }catch{}
};

function findMarketByQuery(q){
  if (!q) return null;
  const Q = q.trim().toUpperCase();

  // 마켓코드 직접 입력
  let m = MARKETS.find(x => x.market.toUpperCase() === Q);
  if (m) return m.market;

  // 한글명 완전/부분
  m = MARKETS.find(x => x.korean_name.replace(/\s/g,'').includes(q.replace(/\s/g,'')));
  if (m) return m.market;

  // 대표 토큰 (비트코인/이더리움 정확히 매칭되도록 우선순위)
  const aliases = {
    '비트코인':'KRW-BTC','BTC':'KRW-BTC',
    '이더리움':'KRW-ETH','ETH':'KRW-ETH',
    '이더리움클래식':'KRW-ETC','ETC':'KRW-ETC',
    '비트코인캐시':'KRW-BCH','BCH':'KRW-BCH'
  };
  if (aliases[Q]) return aliases[Q];
  const kq = q.replace(/\s/g,'');
  for (const k in aliases){
    if (k.includes(kq)) return aliases[k];
  }
  return null;
}

function selectMarket(market){
  LAST_SELECTED = market;
  renderSelected();
  saveState();
}

let searchTimer=null;
function doSearch(){
  const q = $('#q').value;
  const market = findMarketByQuery(q);
  if (market){
    selectMarket(market);
  }else{
    alert('일치하는 코인을 찾지 못했습니다.');
  }
}

$('#btnSearch').onclick = doSearch;
$('#q').addEventListener('input', ()=>{
  clearTimeout(searchTimer);
  searchTimer = setTimeout(doSearch, 600); // 디바운스
});
$('#btnReset').onclick = ()=>{
  $('#q').value='';
  LAST_SELECTED=null; renderSelected(); saveState();
};

/* ========= 갱신 ========= */
async function refreshAll(showToast=true){
  try{
    await loadTickers(KRW);
    renderLists();
    renderSelected();
    if (showToast) console.log('업데이트 완료');
  }catch(e){
    console.error(e);
  }
}
$('#btnRefresh').onclick = ()=>refreshAll(true);

/* ========= 초기 구동 ========= */
(async function init(){
  loadState();
  await loadMarkets();
  await refreshAll(false);

  // 마지막 선택 복원
  if (LAST_SELECTED) renderSelected();

  // 폴링
  if (pollingTimer) clearInterval(pollingTimer);
  pollingTimer = setInterval(refreshAll, 60000);
})();
</script>
<script>
// =========================
// 1) 검색어 → 마켓코드 해석기
// =========================

// 자주 쓰는 별칭/동의어 매핑 (원하는 만큼 추가 가능)
const COIN_ALIASES = {
  // 한글명
  '비트코인': 'KRW-BTC',
  '이더리움': 'KRW-ETH',
  '이더리움클래식': 'KRW-ETC',
  '리플': 'KRW-XRP',
  '도지': 'KRW-DOGE',
  '도지코인': 'KRW-DOGE',
  '시바이누': 'KRW-SHIB',
  '폴리곤': 'KRW-MATIC',
  '카르다노': 'KRW-ADA',
  '솔라나': 'KRW-SOL',

  // 영문 심볼
  'btc': 'KRW-BTC',
  'eth': 'KRW-ETH',
  'etc': 'KRW-ETC',
  'xrp': 'KRW-XRP',
  'doge': 'KRW-DOGE',
  'shib': 'KRW-SHIB',
  'matic': 'KRW-MATIC',
  'ada': 'KRW-ADA',
  'sol': 'KRW-SOL',

  // 마켓코드 축약형 (하이픈 없는 입력도 허용)
  'krwbtc': 'KRW-BTC',
  'krweth': 'KRW-ETH',
  'krwetc': 'KRW-ETC',
  'krwxrp': 'KRW-XRP',
  'krwdoge': 'KRW-DOGE',
  'krwshib': 'KRW-SHIB',
  'krwmatic': 'KRW-MATIC',
  'krwada': 'KRW-ADA',
  'krwsol': 'KRW-SOL',
};

// 업비트 마켓 목록(이미 다른 곳에서 불러오고 있다면 그 배열을 사용하세요)
let ALL_MARKETS = []; // 예: [{market:'KRW-ETH', korean_name:'이더리움', english_name:'Ethereum'}, ...]

// 검색어 전처리
function _norm(s) {
  return (s || '').toString().trim().toLowerCase().replace(/\s+/g, '');
}

// 검색어 → 마켓코드 해석
function resolveMarket(input) {
  const q = _norm(input);
  if (!q) return null;

  // 0) 별칭 테이블 우선
  if (COIN_ALIASES[q]) return COIN_ALIASES[q];

  // 1) “KRW-ETH” / “BTC-ETH” 같은 정식 마켓코드 그대로 입력한 경우
  if (/^[a-z]{3,4}-[a-z0-9]{2,10}$/i.test(input)) return input.toUpperCase();

  // 2) 하이픈 없는 "krweth" 형태
  if (/^[a-z]{3,4}[a-z0-9]{2,10}$/i.test(q)) {
    const base = q.slice(0,3).toUpperCase();
    const sym  = q.slice(3).toUpperCase();
    return `${base}-${sym}`;
  }

  // 3) 마켓 목록에서 한글명/영문명/심볼 일부 일치 검색 (KRW 우선)
  const cand = ALL_MARKETS.filter(m => m.market.startsWith('KRW-'));
  // 우선순위: 정확 일치 → 접두사 → 포함
  const score = (m) => {
    const nameKo = _norm(m.korean_name);
    const nameEn = _norm(m.english_name);
    const sym = m.market.split('-')[1].toLowerCase();

    if (nameKo === q || nameEn === q || sym === q) return 3;
    if (nameKo.startsWith(q) || nameEn.startsWith(q) || sym.startsWith(q)) return 2;
    if (nameKo.includes(q) || nameEn.includes(q)) return 1;
    return 0;
  };
  let best = null, bestScore = 0;
  for (const m of cand) {
    const s = score(m);
    if (s > bestScore) { best = m; bestScore = s; }
  }
  return best ? best.market : null;
}

// 페이지 초기화 시 마켓리스트를 한 번 불러와 저장 (이미 있다면 생략)
async function loadAllMarketsOnce() {
  if (ALL_MARKETS.length) return;
  try {
    const r = await fetch('/api/upbit?path=/v1/market/all?isDetails=true', { cache:'no-store' });
    if (!r.ok) throw new Error(r.status);
    ALL_MARKETS = await r.json();
  } catch(e) {
    console.warn('마켓목록 로딩 실패:', e);
  }
}

// 예: 검색 버튼 클릭 핸들러에서 사용
async function onSearchClick() {
  await loadAllMarketsOnce();
  const q = document.querySelector('#searchInput').value; // 실제 검색 input의 selector로 바꿔주세요
  const market = resolveMarket(q);
  if (!market) {
    alert('해당 코인을 찾을 수 없어요. (한글명/영문명/심볼/마켓코드 지원)');
    return;
  }
  selectCoin(market); // 👉 기존의 “코인 선택” 함수 호출 (당신의 함수 이름으로 교체)
}
</script>
  
</body>
</html>

