// handleSearch/index.js
import { roundByUpbitTick, toFixedSmart, fetchJSON } from "../utils/num.js";

let lastReqId = 0;
let controller = null;

// 한글 → 심볼 매핑
const NAME2SYMBOL = {
  '비트코인': 'BTC',  '이더리움': 'ETH', '리플': 'XRP', '에이다': 'ADA',
  '솔라나': 'SOL',   '시바이누': 'SHIB',
};

function normSymbol(input) {
  const raw = (input || "").trim().toUpperCase();
  // 한글 입력 시 심볼 변환
  for (const [ko, sym] of Object.entries(NAME2SYMBOL)) {
    if (ko.toUpperCase() === raw) return sym;
  }
  return raw;
}

export async function handleSearch(rawInput) {
  const symbol = normSymbol(rawInput || "BTC");
  if (!symbol) return;

  if (controller) controller.abort();
  controller = new AbortController();
  const myReqId = ++lastReqId;

  // UI: 검색중 스피너/뱃지 etc. 업데이트(여기선 예시 – DOM 접근부는 네 기존 코드에 맞춰 연결)
  setStatus("검색 중…");

  try {
    // 업비트 + 김프 병렬
    const [u, k] = await Promise.all([
      fetchJSON(`/api/upbit?symbol=${encodeURIComponent(symbol)}`, { signal: controller.signal, timeout: 4000, retries: 1 }),
      fetchJSON(`/api/kimchi?symbol=${encodeURIComponent(symbol)}`, { signal: controller.signal, timeout: 4000, retries: 1 }),
    ]);

    if (myReqId !== lastReqId) return; // 늦게 온 응답 무시

    // 값 정리
    const price = Number(u.price);
    const bid = Number(u.bid);
    const ask = Number(u.ask);

    // 틱 보정된 타점
    const buyTarget  = roundByUpbitTick(u.buyTarget ?? price);
    const sellTarget = roundByUpbitTick(u.sellTarget ?? price);
    const stopLoss   = roundByUpbitTick(u.stopLoss ?? (price * 0.99));

    // 김프(%) – 요약 박스/뱃지로 표시(표 컬럼 없어도 동작)
    const kimchi = typeof k.kimchi === "number" ? k.kimchi : 0;

    // === 화면 갱신 (여기선 데이터만 반환; 실제 DOM 갱신은 네 구현에 맞춰 바인딩) ===
    const row = {
      symbol: u.symbol,
      price,
      change: u.change,
      bid, ask,
      buyTarget, sellTarget, stopLoss,
      kimchi,
      ts: u.ts,
    };

    renderRow(row);       // <- 네 표 갱신 함수에 연결
    setStatus("완료");    // <- 상태표시

  } catch (e) {
    if (myReqId !== lastReqId) return;
    // 네트워크 오류 시 상태만 갱신(마지막 정상 행은 그대로 유지)
    setStatus("네트워크 지연/오류");
  }
}

// ====== 아래 두 함수는 네 프로젝트의 실제 DOM 제어에 맞게 구현해둔 헬퍼로 연결 ======

function renderRow(row) {
  // 예시: 네가 쓰는 표/카드 구성에 맞춰 필드만 대입하거나 innerText 갱신
  // - 가격/타점: roundByUpbitTick → 표면상 소수점·호가단위 정확
  // - 김프: 별도 칩/뱃지(없으면 상단 요약 박스)로 표시
  // 여긴 네 기존 코드로 바인딩만 해주면 됨.
  // ex)
  // document.querySelector('#price').innerText = toFixedSmart(row.price);
  // document.querySelector('#buy').innerText   = toFixedSmart(row.buyTarget);
  // document.querySelector('#sell').innerText  = toFixedSmart(row.sellTarget);
  // document.querySelector('#sl').innerText    = toFixedSmart(row.stopLoss);
  // document.querySelector('#kimchi').innerText= (row.kimchi>0?'+':'')+row.kimchi.toFixed(2)+'%';
}

function setStatus(text) {
  // 상태 라벨/스피너 제어 – 네 UI id/class 에 맞춰 갱신
  // document.querySelector('#searchStatus').innerText = text;
}
