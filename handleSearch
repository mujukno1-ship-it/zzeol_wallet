// handleSearch/handleSearch.js
// 검색 → 온체인 + 업비트 동시조회, 저가코인 틱 정렬, 호가표시, 현실적인 타점(신호) 제공

let lastReqId = 0;
let controller = null;
let debounceTmr = null;

const NAME2SYMBOL = {
  '비트코인': 'BTC', 'BTC': 'BTC',
  '이더리움': 'ETH', 'ETH': 'ETH',
  '솔라나': 'SOL', 'SOL': 'SOL',
  '리플': 'XRP', 'XRP': 'XRP',
  '에이다': 'ADA', 'ADA': 'ADA',
  '시바이누': 'SHIB', 'SHIB': 'SHIB',
};

function getKrwTickSize(price) {
  if (price >= 2000000) return 1000;
  if (price >= 1000000) return 500;
  if (price >= 500000)  return 100;
  if (price >= 100000)  return 50;
  if (price >= 10000)   return 10;
  if (price >= 1000)    return 1;
  if (price >= 100)     return 0.1;
  if (price >= 10)      return 0.01;
  if (price >= 1)       return 0.001;
  return 0.0001; // 1원 미만 SHIB 같은 초저가 코인
}
function quantizeToTick(price) {
  const tick = getKrwTickSize(price);
  return Math.round(price / tick) * tick;
}
function formatByTick(price) {
  const tick = getKrwTickSize(price);
  const decimals = tick < 1 ? String(tick).split('.')[1].length : 0;
  return Number(price).toFixed(decimals);
}
function setText(sel, val) {
  const el = document.querySelector(sel);
  if (el) el.textContent = val;
}

async function apiJson(url, signal) {
  const r = await fetch(url, { signal, cache: 'no-store' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return await r.json();
}

export async function handleSearch(rawInput) {
  // 요청 ID & 중복취소
  if (controller) controller.abort();
  controller = new AbortController();
  const myReqId = ++lastReqId;

  // 입력 정규화
  const symbol =
    NAME2SYMBOL[rawInput.trim()] ||
    rawInput.trim().toUpperCase();
  if (!symbol) return;

  // 기본 UI 초기화
  setText('#search-symbol', symbol);
  setText('#search-price', '-');
  setText('#search-change', '-');
  setText('#search-bid', '-');
  setText('#search-ask', '-');
  setText('#search-buy', '-');
  setText('#search-sell', '-');
  setText('#search-stop', '-');

  try {
    // 온체인 + 업비트 병렬 조회
    const [onchain, upbit] = await Promise.all([
      // 온체인 API가 symbol을 받도록 되어 있다면 아래처럼 사용
      // 아니다면 기존 엔드포인트 그대로 유지
      apiJson(`/api/onchain?symbol=${encodeURIComponent(symbol)}`, controller.signal).catch(() => null),
      apiJson(`/api/upbit?symbol=${encodeURIComponent(symbol)}`, controller.signal),
    ]);

    // 오래된 응답 무시
    if (myReqId !== lastReqId) return;

    // 업비트 표시
    if (upbit) {
      const { price, changeRate, bid, ask } = upbit;
      setText('#search-price', isFinite(price) ? formatByTick(price) : '-');
      setText('#search-change', isFinite(changeRate) ? `${changeRate.toFixed(2)}%` : '-');
      setText('#search-bid', isFinite(bid) ? formatByTick(bid) : '-');
      setText('#search-ask', isFinite(ask) ? formatByTick(ask) : '-');

      // === 전략 타점(신호) ===
      const baseBid = isFinite(bid) ? bid : price;
      const baseAsk = isFinite(ask) ? ask : price;
      // 예시 전략: 매수=bid -2%, 매도=ask +2%, 손절=bid -4%
      let buy  = isFinite(baseBid) ? quantizeToTick(baseBid * 0.98) : null;
      let sell = isFinite(baseAsk) ? quantizeToTick(baseAsk * 1.02) : null;
      let stop = isFinite(baseBid) ? quantizeToTick(baseBid * 0.96) : null;

      setText('#search-buy',  isFinite(buy)  ? formatByTick(buy)  : '-');
      setText('#search-sell', isFinite(sell) ? formatByTick(sell) : '-');
      setText('#search-stop', isFinite(stop) ? formatByTick(stop) : '-');
    }

    // 온체인 결과가 표/위젯으로 반영되는 부분은
    // 기존 렌더러(사람형 AI, 예열예측, BTC 온체인 상태) 로직이 있으므로 유지
    // (필요시 onchain 객체를 여기서 setText로 보조 표시 가능)
  } catch (e) {
    // 실패 시도 간단 표시
    setText('#search-price', 'ERR');
  }
}

// 입력창에 디바운스 적용 예시 (원하는 곳에서 호출)
export function bindSearchInput(inputSelector = '#search-input') {
  const el = document.querySelector(inputSelector);
  if (!el) return;
  const run = () => {
    const v = el.value || '';
    clearTimeout(debounceTmr);
    debounceTmr = setTimeout(() => handleSearch(v), 180);
  };
  el.addEventListener('input', run);
  el.addEventListener('change', run);
}
